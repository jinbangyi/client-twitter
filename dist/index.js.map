{"version":3,"sources":["../src/base.ts","../src/scraper.ts","../src/settings/index.ts","../src/environment.ts","../src/interactions.ts","../src/utils.ts","../src/post.ts","../src/monitor/metrics.ts","../src/search.ts","../src/spaces.ts","../src/plugins/SttTtsSpacesPlugin.ts","../src/plugins/templates.ts","../src/index.ts"],"sourcesContent":["import {\n  type Content,\n  type IAgentRuntime,\n  type IImageDescriptionService,\n  type Memory,\n  type State,\n  type UUID,\n  getEmbeddingZeroVector,\n  stringToUuid,\n  ActionTimelineType,\n} from '@elizaos/core';\nimport {\n  type QueryTweetsResponse,\n  SearchMode,\n  type Tweet,\n} from 'agent-twitter-client';\nimport { EventEmitter } from 'events';\nimport type { TwitterConfig } from './environment.js';\nimport { CustomScraper } from './scraper.js';\nimport { Logger, SETTINGS } from './settings/index.js';\nimport { TwitterClientState } from './monitor/state.js';\nimport pino from 'pino';\n\nexport function extractAnswer(text: string): string {\n  const startIndex = text.indexOf('Answer: ') + 8;\n  const endIndex = text.indexOf('<|endoftext|>', 11);\n  return text.slice(startIndex, endIndex);\n}\n\ntype TwitterProfile = {\n  id: string;\n  username: string;\n  screenName: string;\n  bio: string;\n  nicknames: string[];\n};\n\nclass RequestQueue {\n  private queue: (() => Promise<any>)[] = [];\n  private processing = false;\n\n  async add<T>(request: () => Promise<T>): Promise<T> {\n    return new Promise((resolve, reject) => {\n      this.queue.push(async () => {\n        try {\n          const result = await request();\n          resolve(result);\n        } catch (error) {\n          reject(error);\n        }\n      });\n      this.processQueue();\n    });\n  }\n\n  private async processQueue(): Promise<void> {\n    if (this.processing || this.queue.length === 0) {\n      return;\n    }\n    this.processing = true;\n\n    while (this.queue.length > 0) {\n      const request = this.queue.shift()!;\n      try {\n        await request();\n      } catch (error) {\n        console.error('Error processing request:', error);\n        this.queue.unshift(request);\n        await this.exponentialBackoff(this.queue.length);\n      }\n      await this.randomDelay();\n    }\n\n    this.processing = false;\n  }\n\n  private async exponentialBackoff(retryCount: number): Promise<void> {\n    const delay = Math.pow(2, retryCount) * 1000;\n    await new Promise((resolve) => setTimeout(resolve, delay));\n  }\n\n  private async randomDelay(): Promise<void> {\n    const delay = Math.floor(Math.random() * 2000) + 1500;\n    await new Promise((resolve) => setTimeout(resolve, delay));\n  }\n}\n\nexport class ClientBase extends EventEmitter {\n  static _twitterClients: { [accountIdentifier: string]: CustomScraper } = {};\n  twitterClient: CustomScraper;\n  runtime: IAgentRuntime;\n  runtimeHelper: RuntimeHelper;\n  twitterConfig: TwitterConfig;\n  directions: string;\n  lastCheckedTweetId: bigint | null = null;\n  imageDescriptionService: IImageDescriptionService;\n  temperature = 0.5;\n\n  requestQueue: RequestQueue = new RequestQueue();\n\n  profile: TwitterProfile | null;\n\n  logger: pino.Logger<string, boolean>;\n\n  async getTweet(tweetId: string): Promise<Tweet> {\n    const cachedTweet = await this.runtimeHelper.getCachedTweet(tweetId);\n\n    if (cachedTweet) {\n      return cachedTweet;\n    }\n\n    const tweet = await this.requestQueue.add(() =>\n      this.twitterClient.getTweet(tweetId),\n    );\n\n    await this.runtimeHelper.cacheTweet(tweet);\n    return tweet;\n  }\n\n  callback: (self: ClientBase) => any = null;\n\n  onReady() {\n    throw new Error('Not implemented in base class, please call from subclass');\n  }\n\n  /**\n   * Parse the raw tweet data into a standardized Tweet object.\n   */\n  private parseTweet(raw: any, depth = 0, maxDepth = 3): Tweet {\n    // If we've reached maxDepth, don't parse nested quotes/retweets further\n    const canRecurse = depth < maxDepth;\n\n    const quotedStatus =\n      raw.quoted_status_result?.result && canRecurse\n        ? this.parseTweet(raw.quoted_status_result.result, depth + 1, maxDepth)\n        : undefined;\n\n    const retweetedStatus =\n      raw.retweeted_status_result?.result && canRecurse\n        ? this.parseTweet(\n            raw.retweeted_status_result.result,\n            depth + 1,\n            maxDepth,\n          )\n        : undefined;\n\n    const t: Tweet = {\n      bookmarkCount:\n        raw.bookmarkCount ?? raw.legacy?.bookmark_count ?? undefined,\n      conversationId: raw.conversationId ?? raw.legacy?.conversation_id_str,\n      hashtags: raw.hashtags ?? raw.legacy?.entities?.hashtags ?? [],\n      html: raw.html,\n      id: raw.id ?? raw.rest_id ?? raw.id_str ?? undefined,\n      inReplyToStatus: raw.inReplyToStatus,\n      inReplyToStatusId:\n        raw.inReplyToStatusId ??\n        raw.legacy?.in_reply_to_status_id_str ??\n        undefined,\n      isQuoted: raw.legacy?.is_quote_status === true,\n      isPin: raw.isPin,\n      isReply: raw.isReply,\n      isRetweet: raw.legacy?.retweeted === true,\n      isSelfThread: raw.isSelfThread,\n      language: raw.legacy?.lang,\n      likes: raw.legacy?.favorite_count ?? 0,\n      name:\n        raw.name ??\n        raw?.user_results?.result?.legacy?.name ??\n        raw.core?.user_results?.result?.legacy?.name,\n      mentions: raw.mentions ?? raw.legacy?.entities?.user_mentions ?? [],\n      permanentUrl:\n        raw.permanentUrl ??\n        (raw.core?.user_results?.result?.legacy?.screen_name && raw.rest_id\n          ? `https://x.com/${raw.core?.user_results?.result?.legacy?.screen_name}/status/${raw.rest_id}`\n          : undefined),\n      photos:\n        raw.photos ??\n        (raw.legacy?.entities?.media\n          ?.filter((media: any) => media.type === 'photo')\n          .map((media: any) => ({\n            id: media.id_str,\n            url: media.media_url_https,\n            alt_text: media.alt_text,\n          })) ||\n          []),\n      place: raw.place,\n      poll: raw.poll ?? null,\n      quotedStatus,\n      quotedStatusId:\n        raw.quotedStatusId ?? raw.legacy?.quoted_status_id_str ?? undefined,\n      quotes: raw.legacy?.quote_count ?? 0,\n      replies: raw.legacy?.reply_count ?? 0,\n      retweets: raw.legacy?.retweet_count ?? 0,\n      retweetedStatus,\n      retweetedStatusId: raw.legacy?.retweeted_status_id_str ?? undefined,\n      text: raw.text ?? raw.legacy?.full_text ?? undefined,\n      thread: raw.thread || [],\n      timeParsed: raw.timeParsed\n        ? new Date(raw.timeParsed)\n        : raw.legacy?.created_at\n          ? new Date(raw.legacy?.created_at)\n          : undefined,\n      timestamp:\n        raw.timestamp ??\n        (raw.legacy?.created_at\n          ? new Date(raw.legacy.created_at).getTime() / 1000\n          : undefined),\n      urls: raw.urls ?? raw.legacy?.entities?.urls ?? [],\n      userId: raw.userId ?? raw.legacy?.user_id_str ?? undefined,\n      username:\n        raw.username ??\n        raw.core?.user_results?.result?.legacy?.screen_name ??\n        undefined,\n      videos:\n        raw.videos ??\n        raw.legacy?.entities?.media?.filter(\n          (media: any) => media.type === 'video',\n        ) ??\n        [],\n      views: raw.views?.count ? Number(raw.views.count) : 0,\n      sensitiveContent: raw.sensitiveContent,\n    };\n\n    return t;\n  }\n\n  constructor(runtime: IAgentRuntime, twitterConfig: TwitterConfig) {\n    super();\n    this.runtime = runtime;\n    this.twitterConfig = twitterConfig;\n    // TODO fix when twitter username changed\n    this.logger = Logger.child({\n      twitterName: this.twitterConfig.TWITTER_USERNAME,\n      name: this.twitterConfig.TWITTER_USERNAME,\n    });\n    this.runtimeHelper = new RuntimeHelper(runtime, this.logger);\n    const username = twitterConfig.TWITTER_USERNAME;\n\n    if (ClientBase._twitterClients[username]) {\n      this.twitterClient = ClientBase._twitterClients[username];\n    } else {\n      this.twitterClient = new CustomScraper(\n        {\n          transform: (data) => {\n            if (data.__typename === 'Tweet') {\n              return this.parseTweet(data);\n            }\n            return data;\n          },\n        },\n        this.twitterConfig.TWITTER_HTTP_PROXY,\n      );\n      ClientBase._twitterClients[username] = this.twitterClient;\n    }\n\n    this.directions = this.runtimeHelper.getDirections();\n  }\n\n  private async twitterLoginInitCookies() {\n    const username = this.twitterConfig.TWITTER_USERNAME;\n    const authToken = this.twitterConfig.TWITTER_COOKIES_AUTH_TOKEN;\n    const ct0 = this.twitterConfig.TWITTER_COOKIES_CT0;\n    const guestId = this.twitterConfig.TWITTER_COOKIES_GUEST_ID;\n\n    this.logger.debug('Waiting for Twitter login cookie init');\n    SETTINGS.account[username] = {\n      ...SETTINGS.account[username],\n      state: TwitterClientState.TWITTER_LOGIN_COOKIE_INIT,\n    };\n\n    const createTwitterCookies = (\n      authToken: string,\n      ct0: string,\n      guestId: string,\n    ) =>\n      authToken && ct0 && guestId\n        ? [\n            { key: 'auth_token', value: authToken, domain: '.twitter.com' },\n            { key: 'ct0', value: ct0, domain: '.twitter.com' },\n            { key: 'guest_id', value: guestId, domain: '.twitter.com' },\n          ]\n        : null;\n\n    const cachedCookies =\n      (await this.runtimeHelper.getCachedCookies(username)) ||\n      createTwitterCookies(authToken, ct0, guestId);\n\n    if (cachedCookies) {\n      this.logger.info('Using cached cookies');\n      await this.setCookiesFromArray(cachedCookies);\n    }\n  }\n\n  private async twitterLogin() {\n    const username = this.twitterConfig.TWITTER_USERNAME;\n    let retries = this.twitterConfig.TWITTER_RETRY_LIMIT;\n\n    this.logger.debug('Waiting for Twitter login');\n    SETTINGS.account[username] = {\n      ...SETTINGS.account[username],\n      state: TwitterClientState.TWITTER_LOGIN,\n    };\n\n    while (retries > 0) {\n      try {\n        if (await this.twitterClient.isLoggedIn()) {\n          // cookies are valid, no login required\n          this.logger.info('Successfully logged in.');\n          break;\n        } else {\n          await this.twitterClient.login(\n            username,\n            this.twitterConfig.TWITTER_PASSWORD,\n            this.twitterConfig.TWITTER_EMAIL,\n            this.twitterConfig.TWITTER_2FA_SECRET,\n          );\n          if (await this.twitterClient.isLoggedIn()) {\n            // fresh login, store new cookies\n            this.logger.info('Successfully logged in.');\n            this.logger.info('Caching cookies');\n            await this.runtimeHelper.cacheCookies(\n              username,\n              await this.twitterClient.getCookies(),\n            );\n            break;\n          }\n        }\n      } catch (error) {\n        this.logger.error(`Login attempt failed: ${error.message}`);\n      }\n\n      retries--;\n      this.logger.error(\n        `Failed to login to Twitter. Retrying... (${retries} attempts left)`,\n      );\n\n      if (retries === 0) {\n        this.logger.error('Max retries reached. Exiting login process.');\n        throw new Error('Twitter login failed after maximum retries.');\n      }\n\n      await new Promise((resolve) => setTimeout(resolve, 2000));\n    }\n  }\n\n  private async initTwitterProfile() {\n    const username = this.twitterConfig.TWITTER_USERNAME;\n\n    this.logger.debug('Waiting for Twitter profile init');\n    SETTINGS.account[username] = {\n      ...SETTINGS.account[username],\n      state: TwitterClientState.TWITTER_PROFILE_INIT,\n    };\n\n    this.profile = await this.fetchProfile(username);\n\n    if (this.profile) {\n      this.logger.debug('Twitter user ID:', this.profile.id);\n      this.logger.debug('Twitter loaded:', JSON.stringify(this.profile));\n      // Store profile info for use in responses\n      this.runtimeHelper.setTwitterProfile(this.profile);\n    } else {\n      throw new Error('Failed to load profile');\n    }\n  }\n\n  async init() {\n    await this.twitterLoginInitCookies();\n    await this.twitterLogin();\n    await this.initTwitterProfile();\n    await this.loadLatestCheckedTweetId();\n    await this.populateTimeline();\n  }\n\n  async fetchOwnPosts(count: number): Promise<Tweet[]> {\n    this.logger.debug('fetching own posts');\n    const homeTimeline = await this.twitterClient.getUserTweets(\n      this.profile.id,\n      count,\n    );\n    // Use parseTweet on each tweet\n    return homeTimeline.tweets.map((t) => this.parseTweet(t));\n  }\n\n  /**\n   * Fetch timeline for twitter account, optionally only from followed accounts\n   */\n  async fetchHomeTimeline(\n    count: number,\n    following?: boolean,\n  ): Promise<Tweet[]> {\n    this.logger.debug('fetching home timeline');\n    const homeTimeline = following\n      ? await this.twitterClient.fetchFollowingTimeline(count, [])\n      : await this.twitterClient.fetchHomeTimeline(count, []);\n\n    // this.logger.debug(homeTimeline, { depth: Number.POSITIVE_INFINITY });\n    const processedTimeline = homeTimeline\n      .filter((t) => t.__typename !== 'TweetWithVisibilityResults') // what's this about?\n      .map((tweet) => this.parseTweet(tweet));\n\n    //this.logger.debug(\"process homeTimeline\", processedTimeline);\n    return processedTimeline;\n  }\n\n  async fetchTimelineForActions(count: number): Promise<Tweet[]> {\n    this.logger.debug('fetching timeline for actions');\n\n    const agentUsername = this.twitterConfig.TWITTER_USERNAME;\n\n    const homeTimeline =\n      this.twitterConfig.ACTION_TIMELINE_TYPE === ActionTimelineType.Following\n        ? await this.twitterClient.fetchFollowingTimeline(count, [])\n        : await this.twitterClient.fetchHomeTimeline(count, []);\n\n    // Parse, filter out self-tweets, limit to count\n    return homeTimeline\n      .map((tweet) => this.parseTweet(tweet))\n      .filter((tweet) => tweet.username !== agentUsername) // do not perform action on self-tweets\n      .slice(0, count);\n    // TODO: Once the 'count' parameter is fixed in the 'fetchTimeline' method of the 'agent-twitter-client',\n    // this workaround can be removed.\n    // Related issue: https://github.com/elizaos/agent-twitter-client/issues/43\n  }\n\n  async fetchSearchTweets(\n    query: string,\n    maxTweets: number,\n    searchMode: SearchMode,\n    cursor?: string,\n  ): Promise<QueryTweetsResponse> {\n    try {\n      // Sometimes this fails because we are rate limited. in this case, we just need to return an empty array\n      // if we dont get a response in 5 seconds, something is wrong\n      const timeoutPromise = new Promise((resolve) =>\n        setTimeout(() => resolve({ tweets: [] }), 15000),\n      );\n\n      try {\n        const result = await this.requestQueue.add(\n          async () =>\n            await Promise.race([\n              this.twitterClient.fetchSearchTweets(\n                query,\n                maxTweets,\n                searchMode,\n                cursor,\n              ),\n              timeoutPromise,\n            ]),\n        );\n        return (result ?? { tweets: [] }) as QueryTweetsResponse;\n      } catch (error) {\n        this.logger.error('Error fetching search tweets:', error);\n        return { tweets: [] };\n      }\n    } catch (error) {\n      this.logger.error('Error fetching search tweets:', error);\n      return { tweets: [] };\n    }\n  }\n\n  private async populateTimeline() {\n    const username = this.twitterConfig.TWITTER_USERNAME;\n\n    this.logger.debug('populating timeline...');\n    SETTINGS.account[username] = {\n      ...SETTINGS.account[username],\n      state: TwitterClientState.TWITTER_POPULATE_TIMELINE,\n    };\n\n    const cachedTimeline = await this.runtimeHelper.getOrCreateCachedTimeline(\n      this.profile,\n    );\n    if (cachedTimeline.ret) return;\n\n    const timeline = await this.fetchHomeTimeline(cachedTimeline.res ? 10 : 50);\n\n    // Get the most recent 20 mentions and interactions\n    const mentionsAndInteractions = await this.fetchSearchTweets(\n      `@${username}`,\n      20,\n      SearchMode.Latest,\n    );\n\n    // Combine the timeline tweets and mentions/interactions\n    const allTweets = [...timeline, ...mentionsAndInteractions.tweets];\n    // Create a Set to store unique tweet IDs\n    const roomIds = new Set<UUID>();\n\n    // Add tweet IDs to the Set\n    for (const tweet of allTweets) {\n      roomIds.add(this.runtimeHelper.getTweetRoomId(tweet.conversationId));\n    }\n    // Create a Set to store the existing memory IDs\n    const existingMemoryIds = await this.runtimeHelper.getMemoryIdsByRoomIds(\n      Array.from(roomIds),\n    );\n    // Filter out the tweets that already exist in the database\n    const tweetsToSave = allTweets.filter(\n      (tweet) =>\n        !existingMemoryIds.has(this.runtimeHelper.getTweetMemoryId(tweet.id)),\n    );\n\n    this.logger.debug('processingTweets: ', JSON.stringify({\n      processingTweets: tweetsToSave.map((tweet) => tweet.id).join(','),\n    }));\n\n    await this.runtimeHelper.ensureUserExists(username);\n    // Save the new tweets as memories\n    await this.runtimeHelper.saveTweets(this.profile, tweetsToSave, {\n      inReplyToAddAgentId: false,\n      checkMemoryExists: false,\n    });\n\n    // Cache\n    await this.cacheTimeline(timeline);\n    await this.runtimeHelper.cacheMentions(\n      username,\n      mentionsAndInteractions.tweets,\n    );\n  }\n\n  private async setCookiesFromArray(cookiesArray: any[]) {\n    const cookieStrings = cookiesArray.map(\n      (cookie) =>\n        `${cookie.key}=${cookie.value}; Domain=${cookie.domain}; Path=${cookie.path}; ${\n          cookie.secure ? 'Secure' : ''\n        }; ${cookie.httpOnly ? 'HttpOnly' : ''}; SameSite=${\n          cookie.sameSite || 'Lax'\n        }`,\n    );\n    await this.twitterClient.setCookies(cookieStrings);\n  }\n\n  async saveRequestMessage(message: Memory, state: State) {\n    return this.runtimeHelper.saveRequestMessage(\n      message,\n      state,\n      this.twitterClient,\n    );\n  }\n\n  private async loadLatestCheckedTweetId(): Promise<void> {\n    const latestCheckedTweetId =\n      await this.runtimeHelper.getCachedLatestCheckedTweetId(\n        this.profile.username,\n      );\n\n    if (latestCheckedTweetId) {\n      this.lastCheckedTweetId = latestCheckedTweetId;\n    }\n  }\n\n  async cacheLatestCheckedTweetId() {\n    if (this.lastCheckedTweetId) {\n      await this.runtimeHelper.cacheLatestCheckedTweetId(\n        this.profile.username,\n        this.lastCheckedTweetId,\n      );\n    }\n  }\n\n  async cacheTimeline(timeline: Tweet[]) {\n    await this.runtimeHelper.cacheTimeline(this.profile.username, timeline);\n  }\n\n  private async fetchProfile(username: string): Promise<TwitterProfile> {\n    try {\n      const profile = await this.twitterClient.getProfile(username);\n      const character = this.runtimeHelper.getCharacter();\n      return {\n        id: profile.userId,\n        username,\n        screenName: profile.name || character.name,\n        bio:\n          profile.biography || typeof character.bio === 'string'\n            ? (character.bio as string)\n            : character.bio.length > 0\n              ? character.bio[0]\n              : '',\n        nicknames: character.twitterProfile?.nicknames || [],\n      } satisfies TwitterProfile;\n    } catch (error) {\n      console.error('Error fetching Twitter profile:', error);\n      throw error;\n    }\n  }\n}\n\nclass RuntimeHelper {\n  // TODO add runtime helper to base class\n  constructor(\n    private runtime: IAgentRuntime,\n    private logger: pino.Logger<string, boolean>,\n  ) {}\n\n  async saveRequestMessage(\n    message: Memory,\n    state: State,\n    twitterClient: CustomScraper,\n  ) {\n    if (message.content.text) {\n      const recentMessage = await this.runtime.messageManager.getMemories({\n        roomId: message.roomId,\n        count: 1,\n        unique: false,\n      });\n\n      if (\n        recentMessage.length > 0 &&\n        recentMessage[0].content === message.content\n      ) {\n        this.logger.debug('Message already saved', recentMessage[0].id);\n      } else {\n        await this.runtime.messageManager.createMemory({\n          ...message,\n          embedding: getEmbeddingZeroVector(),\n        });\n      }\n\n      await this.runtime.evaluate(message, {\n        ...state,\n        twitterClient: twitterClient,\n      });\n    }\n  }\n\n  getDirections() {\n    const ret =\n      '- ' +\n      this.runtime.character.style.all.join('\\n- ') +\n      '- ' +\n      this.runtime.character.style.post.join();\n    return ret;\n  }\n\n  async cacheTweet(tweet: Tweet): Promise<void> {\n    if (!tweet) {\n      console.warn('Tweet is undefined, skipping cache');\n      return;\n    }\n\n    this.runtime.cacheManager.set(`twitter/tweets/${tweet.id}`, tweet);\n  }\n\n  async getCachedTweet(tweetId: string): Promise<Tweet | undefined> {\n    const cached = await this.runtime.cacheManager.get<Tweet>(\n      `twitter/tweets/${tweetId}`,\n    );\n\n    return cached;\n  }\n\n  async getCachedLatestCheckedTweetId(\n    username: string,\n  ): Promise<bigint | undefined> {\n    const latestCheckedTweetId = await this.runtime.cacheManager.get<string>(\n      `twitter/${username}/latest_checked_tweet_id`,\n    );\n\n    if (latestCheckedTweetId) {\n      return BigInt(latestCheckedTweetId);\n    }\n  }\n\n  async cacheLatestCheckedTweetId(\n    username: string,\n    lastCheckedTweetId: BigInt,\n  ) {\n    await this.runtime.cacheManager.set(\n      `twitter/${username}/latest_checked_tweet_id`,\n      lastCheckedTweetId.toString(),\n    );\n  }\n\n  async getCachedTimeline(username: string): Promise<Tweet[] | undefined> {\n    return await this.runtime.cacheManager.get<Tweet[]>(\n      `twitter/${username}/timeline`,\n    );\n  }\n\n  async ensureUserExists(username: string) {\n    await this.runtime.ensureUserExists(\n      this.runtime.agentId,\n      username,\n      this.runtime.character.name,\n      'twitter',\n    );\n  }\n\n  async getMemoryIdsByRoomIds(roomIds: UUID[]): Promise<Set<UUID>> {\n    const existingMemories =\n      await this.runtime.messageManager.getMemoriesByRoomIds({\n        roomIds: roomIds,\n      });\n\n    const existingMemoryIds = new Set<UUID>(\n      existingMemories.map((memory) => memory.id),\n    );\n\n    return existingMemoryIds;\n  }\n\n  getTweetRoomId(conversationId?: string): UUID {\n    return stringToUuid(conversationId + '-' + this.runtime.agentId);\n  }\n\n  getTweetMemoryId(tweetId?: string) {\n    return this.getTweetRoomId(tweetId);\n  }\n\n  async saveTweets(\n    profile: TwitterProfile,\n    tweetsToSave: Tweet[],\n    options = {\n      inReplyToAddAgentId: true,\n      checkMemoryExists: true,\n    },\n  ) {\n    // Save the missing tweets as memories\n    for (const tweet of tweetsToSave) {\n      this.logger.debug('Saving Tweet', tweet.id);\n\n      const roomId = stringToUuid(\n        tweet.conversationId + '-' + this.runtime.agentId,\n      );\n\n      const userId =\n        tweet.userId === profile.id\n          ? this.runtime.agentId\n          : stringToUuid(tweet.userId);\n\n      if (tweet.userId === profile.id) {\n        await this.runtime.ensureConnection(\n          this.runtime.agentId,\n          roomId,\n          profile.username,\n          profile.screenName,\n          'twitter',\n        );\n      } else {\n        await this.runtime.ensureConnection(\n          userId,\n          roomId,\n          tweet.username,\n          tweet.name,\n          'twitter',\n        );\n      }\n\n      const inReplyTo = () => {\n        if (options.inReplyToAddAgentId) {\n          return tweet.inReplyToStatusId\n            ? stringToUuid(tweet.inReplyToStatusId + '-' + this.runtime.agentId)\n            : undefined;\n        } else {\n          return tweet.inReplyToStatusId\n            ? stringToUuid(tweet.inReplyToStatusId)\n            : undefined;\n        }\n      };\n\n      const content = {\n        text: tweet.text,\n        url: tweet.permanentUrl,\n        source: 'twitter',\n        inReplyTo: inReplyTo(),\n      } as Content;\n\n      this.logger.debug('Creating memory for tweet', tweet.id);\n\n      if (options.checkMemoryExists) {\n        // check if it already exists\n        const memory = await this.runtime.messageManager.getMemoryById(\n          stringToUuid(tweet.id + '-' + this.runtime.agentId),\n        );\n\n        if (memory) {\n          this.logger.info(\n            'Memory already exists, skipping timeline population',\n          );\n          break;\n        }\n      }\n\n      await this.runtime.messageManager.createMemory({\n        id: stringToUuid(tweet.id + '-' + this.runtime.agentId),\n        userId,\n        content: content,\n        agentId: this.runtime.agentId,\n        roomId,\n        embedding: getEmbeddingZeroVector(),\n        createdAt: tweet.timestamp * 1000,\n      });\n\n      await this.cacheTweet(tweet);\n    }\n  }\n\n  async getOrCreateCachedTimeline(\n    profile: TwitterProfile,\n  ): Promise<{ ret: boolean; res?: Tweet[] }> {\n    const username = profile.username;\n\n    const cachedTimeline = await this.getCachedTimeline(username);\n\n    // Check if the cache file exists\n    if (cachedTimeline) {\n      // Read the cached search results from the file\n\n      // Get the existing memories from the database\n      const existingMemories =\n        await this.runtime.messageManager.getMemoriesByRoomIds({\n          roomIds: cachedTimeline.map((tweet) =>\n            stringToUuid(tweet.conversationId + '-' + this.runtime.agentId),\n          ),\n        });\n\n      //TODO: load tweets not in cache?\n\n      // Create a Set to store the IDs of existing memories\n      const existingMemoryIds = new Set(\n        existingMemories.map((memory) => memory.id.toString()),\n      );\n\n      // Check if any of the cached tweets exist in the existing memories\n      const someCachedTweetsExist = cachedTimeline.some((tweet) =>\n        existingMemoryIds.has(\n          stringToUuid(tweet.id + '-' + this.runtime.agentId),\n        ),\n      );\n\n      if (someCachedTweetsExist) {\n        // Filter out the cached tweets that already exist in the database\n        const tweetsToSave = cachedTimeline.filter(\n          (tweet) =>\n            !existingMemoryIds.has(\n              stringToUuid(tweet.id + '-' + this.runtime.agentId),\n            ),\n        );\n\n        this.logger.debug({\n          processingTweets: tweetsToSave.map((tweet) => tweet.id).join(','),\n        });\n\n        // Save the missing tweets as memories\n        await this.saveTweets(profile, tweetsToSave);\n\n        this.logger.debug(\n          `Populated ${tweetsToSave.length} missing tweets from the cache.`,\n        );\n        return { ret: true };\n      }\n    }\n\n    return { ret: false, res: cachedTimeline };\n  }\n\n  async cacheTimeline(username: string, timeline: Tweet[]) {\n    await this.runtime.cacheManager.set(\n      `twitter/${username}/timeline`,\n      timeline,\n      { expires: Date.now() + 10 * 1000 },\n    );\n  }\n\n  async cacheMentions(username: string, mentions: Tweet[]) {\n    await this.runtime.cacheManager.set(\n      `twitter/${username}/mentions`,\n      mentions,\n      { expires: Date.now() + 10 * 1000 },\n    );\n  }\n\n  async getCachedCookies(username: string) {\n    return await this.runtime.cacheManager.get<any[]>(\n      `twitter/${username}/cookies`,\n    );\n  }\n\n  async cacheCookies(username: string, cookies: any[]) {\n    await this.runtime.cacheManager.set(`twitter/${username}/cookies`, cookies);\n  }\n\n  setTwitterProfile(profile: TwitterProfile) {\n    this.runtime.character.twitterProfile = {\n      id: profile.id,\n      username: profile.username,\n      screenName: profile.screenName,\n      bio: profile.bio,\n      nicknames: profile.nicknames,\n    };\n  }\n\n  getCharacter() {\n    return this.runtime.character;\n  }\n}\n","import { Scraper } from 'agent-twitter-client';\nimport { HttpsProxyAgent } from 'https-proxy-agent';\nimport axios, { AxiosRequestConfig, AxiosResponse } from 'axios';\n\nexport type FetchParameters = [input: RequestInfo | URL, init?: RequestInit];\nexport interface FetchTransformOptions {\n  /**\n   * Transforms the request options before a request is made. This executes after all of the default\n   * parameters have been configured, and is stateless. It is safe to return new request options\n   * objects.\n   * @param args The request options.\n   * @returns The transformed request options.\n   */\n  request: (\n    ...args: FetchParameters\n  ) => FetchParameters | Promise<FetchParameters>;\n  /**\n   * Transforms the response after a request completes. This executes immediately after the request\n   * completes, and is stateless. It is safe to return a new response object.\n   * @param response The response object.\n   * @returns The transformed response object.\n   */\n  response: (response: Response) => Response | Promise<Response>;\n}\n\nexport interface ScraperOptions {\n  /**\n   * An alternative fetch function to use instead of the default fetch function. This may be useful\n   * in nonstandard runtime environments, such as edge workers.\n   */\n  fetch: typeof fetch;\n  /**\n   * Additional options that control how requests and responses are processed. This can be used to\n   * proxy requests through other hosts, for example.\n   */\n  transform: Partial<FetchTransformOptions>;\n}\n\nexport function wrapperFetchFunction(proxyUrl?: string) {\n  let agent = undefined;\n  if (proxyUrl) {\n    agent = new HttpsProxyAgent(proxyUrl);\n  }\n\n  return async (\n    input: RequestInfo | URL,\n    init?: RequestInit,\n  ): Promise<Response> => {\n    // console.log(input);\n    // console.log(init.headers);\n\n    /**\n     * // Object.fromEntries(init.headers as any)\n     *  headers: _Headers {\n          [Symbol(normalizedHeaders)]: {\n            authorization: 'Bearer xx',\n            cookie: 'xx',\n            'x-csrf-token': 'xx'\n          },\n          [Symbol(rawHeaderNames)]: Map(3) {\n            'authorization' => 'authorization',\n            'cookie' => 'cookie',\n            'x-csrf-token' => 'x-csrf-token'\n          }\n        }\n    */\n    let headers: Record<string, string> = undefined;\n    try {\n      if (init?.headers) headers = Object.fromEntries(init.headers as any);\n    } catch (error) {\n      if (\n        error.toString() ===\n        'TypeError: object is not iterable (cannot read property Symbol(Symbol.iterator))'\n      ) {\n        headers = init?.headers as any;\n      } else {\n        // console.log(error)\n        throw error;\n      }\n    }\n\n    // console.log(headers);\n\n    const params: AxiosRequestConfig = {\n      url: input.toString(),\n      method: init?.method || 'GET',\n      headers,\n      data: init?.body,\n      httpsAgent: agent,\n    };\n\n    // console.log(params)\n\n    let response: AxiosResponse;\n    try {\n      response = await axios.request(params);\n    } catch (error) {\n      // console.log(error);\n      throw error;\n    }\n\n    const data =\n      typeof response.data === 'object'\n        ? JSON.stringify(response.data)\n        : response.data;\n\n    return new Response(data, {\n      status: response.status,\n      statusText: response.statusText,\n      headers: new Headers(response.headers as Record<string, string>),\n    });\n  };\n}\n\nexport class CustomScraper extends Scraper {\n  constructor(\n    options?: Partial<ScraperOptions> | undefined,\n    proxyUrl?: string,\n  ) {\n    super({\n      fetch: wrapperFetchFunction(proxyUrl),\n      // using options\n      transform: options?.transform,\n    });\n  }\n}\n","import { elizaLogger, UUID } from '@elizaos/core';\nimport pino from 'pino';\nimport { TwitterClientState, TwitterClientStatus } from '../monitor/state';\nimport { TwitterConfig } from '../environment';\n\ninterface Settings {\n  // agentId, twitter username\n  agent: Record<string, TwitterConfig>;\n  account: Record<\n    string,\n    {\n      state: TwitterClientState;\n      status: TwitterClientStatus;\n      // TODO, fix circular import.\n      // TwitterManager | null\n      manager: any;\n    }\n  >;\n}\n\nexport function getCurrentTwitterAccountStatus(\n  username: string,\n): TwitterClientStatus {\n  if (!SETTINGS.account[username]) return TwitterClientStatus.STOPPED;\n\n  return SETTINGS.account[username].status;\n}\n\nexport function getCurrentAgentTwitterAccountStatus(\n  agentId: UUID,\n): TwitterClientStatus {\n  if (!SETTINGS.agent[agentId.toString()]) return TwitterClientStatus.STOPPED;\n\n  const twitterConfig = SETTINGS.agent[agentId.toString()];\n  return getCurrentTwitterAccountStatus(twitterConfig.TWITTER_USERNAME);\n}\n\nexport function isAgentTwitterAccountStopped(agentId: UUID): boolean {\n  return (\n    getCurrentAgentTwitterAccountStatus(agentId) === TwitterClientStatus.STOPPED\n  );\n}\n\nexport function isAgentTwitterAccountStopping(agentId: UUID): boolean {\n  return (\n    getCurrentAgentTwitterAccountStatus(agentId) ===\n    TwitterClientStatus.STOPPING\n  );\n}\n\nexport const Logger: pino.Logger<string, boolean> = elizaLogger.child({\n  plugin: 'client-twitter',\n});\nexport const SETTINGS: Settings = {\n  account: {},\n  agent: {},\n};\n","import {\n  parseBooleanFromText,\n  type IAgentRuntime,\n  ActionTimelineType,\n} from '@elizaos/core';\nimport { z, ZodError } from 'zod';\n\nexport const DEFAULT_MAX_TWEET_LENGTH = 280;\n\nconst twitterUsernameSchema = z\n  .string()\n  .min(1, 'An X/Twitter Username must be at least 1 character long')\n  .max(15, 'An X/Twitter Username cannot exceed 15 characters')\n  .refine((username) => {\n    // Allow wildcard '*' as a special case\n    if (username === '*') return true;\n\n    // Twitter usernames can:\n    // - Start with digits now\n    // - Contain letters, numbers, underscores\n    // - Must not be empty\n    return /^[A-Za-z0-9_]+$/.test(username);\n  }, 'An X Username can only contain letters, numbers, and underscores');\n\n/**\n * This schema defines all required/optional environment settings,\n * including new fields like TWITTER_SPACES_ENABLE.\n */\nexport const twitterEnvSchema = z.object({\n  TWITTER_DRY_RUN: z.boolean(),\n  TWITTER_USERNAME: z.string().min(1, 'X/Twitter username is required'),\n  TWITTER_PASSWORD: z.string().min(1, 'X/Twitter password is required'),\n  TWITTER_EMAIL: z.string().email('Valid X/Twitter email is required'),\n  MAX_TWEET_LENGTH: z.number().int().default(DEFAULT_MAX_TWEET_LENGTH),\n  TWITTER_SEARCH_ENABLE: z.boolean().default(false),\n  TWITTER_2FA_SECRET: z.string(),\n  TWITTER_RETRY_LIMIT: z.number().int(),\n  TWITTER_POLL_INTERVAL: z.number().int(),\n  TWITTER_TARGET_USERS: z.array(twitterUsernameSchema).default([]),\n  // I guess it's possible to do the transformation with zod\n  // not sure it's preferable, maybe a readability issue\n  // since more people will know js/ts than zod\n  /*\n        z\n        .string()\n        .transform((val) => val.trim())\n        .pipe(\n            z.string()\n                .transform((val) =>\n                    val ? val.split(',').map((u) => u.trim()).filter(Boolean) : []\n                )\n                .pipe(\n                    z.array(\n                        z.string()\n                            .min(1)\n                            .max(15)\n                            .regex(\n                                /^[A-Za-z][A-Za-z0-9_]*[A-Za-z0-9]$|^[A-Za-z]$/,\n                                'Invalid Twitter username format'\n                            )\n                    )\n                )\n                .transform((users) => users.join(','))\n        )\n        .optional()\n        .default(''),\n    */\n  ENABLE_TWITTER_POST_GENERATION: z.boolean(),\n  POST_INTERVAL_MIN: z.number().int(),\n  POST_INTERVAL_MAX: z.number().int(),\n  ENABLE_ACTION_PROCESSING: z.boolean(),\n  ACTION_INTERVAL: z.number().int(),\n  POST_IMMEDIATELY: z.boolean(),\n  TWITTER_SPACES_ENABLE: z.boolean().default(false),\n  MAX_ACTIONS_PROCESSING: z.number().int(),\n  ACTION_TIMELINE_TYPE: z\n    .nativeEnum(ActionTimelineType)\n    .default(ActionTimelineType.ForYou),\n  TWITTER_HTTP_PROXY: z.string().optional(),\n\n  TWITTER_COOKIES_AUTH_TOKEN: z.string().optional(),\n  TWITTER_COOKIES_CT0: z.string().optional(),\n  TWITTER_COOKIES_GUEST_ID: z.string().optional(),\n});\n\nexport type TwitterConfig = z.infer<typeof twitterEnvSchema>;\n\n/**\n * Helper to parse a comma-separated list of Twitter usernames\n * (already present in your code).\n */\nfunction parseTargetUsers(targetUsersStr?: string | null): string[] {\n  if (!targetUsersStr?.trim()) {\n    return [];\n  }\n  return targetUsersStr\n    .split(',')\n    .map((user) => user.trim())\n    .filter(Boolean);\n}\n\nfunction safeParseInt(\n  value: string | undefined | null,\n  defaultValue: number,\n): number {\n  if (!value) return defaultValue;\n  const parsed = Number.parseInt(value, 10);\n  return isNaN(parsed) ? defaultValue : Math.max(1, parsed);\n}\n\n/**\n * Validates or constructs a TwitterConfig object using zod,\n * taking values from the IAgentRuntime or process.env as needed.\n */\n// This also is organized to serve as a point of documentation for the client\n// most of the inputs from the framework (env/character)\n\n// we also do a lot of typing/parsing here\n// so we can do it once and only once per character\nexport async function validateTwitterConfig(\n  runtime: IAgentRuntime,\n): Promise<TwitterConfig> {\n  try {\n    const twitterConfig = {\n      TWITTER_DRY_RUN:\n        parseBooleanFromText(\n          runtime.getSetting('TWITTER_DRY_RUN') || process.env.TWITTER_DRY_RUN,\n        ) ?? false, // parseBooleanFromText return null if \"\", map \"\" to false\n\n      TWITTER_USERNAME:\n        runtime.getSetting('TWITTER_USERNAME') || process.env.TWITTER_USERNAME,\n\n      TWITTER_PASSWORD:\n        runtime.getSetting('TWITTER_PASSWORD') || process.env.TWITTER_PASSWORD,\n\n      TWITTER_EMAIL:\n        runtime.getSetting('TWITTER_EMAIL') || process.env.TWITTER_EMAIL,\n\n      // number as string?\n      MAX_TWEET_LENGTH: safeParseInt(\n        runtime.getSetting('MAX_TWEET_LENGTH') || process.env.MAX_TWEET_LENGTH,\n        DEFAULT_MAX_TWEET_LENGTH,\n      ),\n\n      TWITTER_SEARCH_ENABLE:\n        parseBooleanFromText(\n          runtime.getSetting('TWITTER_SEARCH_ENABLE') ||\n            process.env.TWITTER_SEARCH_ENABLE,\n        ) ?? false,\n\n      // string passthru\n      TWITTER_2FA_SECRET:\n        runtime.getSetting('TWITTER_2FA_SECRET') ||\n        process.env.TWITTER_2FA_SECRET ||\n        '',\n\n      // int\n      TWITTER_RETRY_LIMIT: safeParseInt(\n        runtime.getSetting('TWITTER_RETRY_LIMIT') ||\n          process.env.TWITTER_RETRY_LIMIT,\n        5,\n      ),\n\n      // int in seconds\n      TWITTER_POLL_INTERVAL: safeParseInt(\n        runtime.getSetting('TWITTER_POLL_INTERVAL') ||\n          process.env.TWITTER_POLL_INTERVAL,\n        120, // 2m\n      ),\n\n      // comma separated string\n      TWITTER_TARGET_USERS: parseTargetUsers(\n        runtime.getSetting('TWITTER_TARGET_USERS') ||\n          process.env.TWITTER_TARGET_USERS,\n      ),\n\n      // bool\n      ENABLE_TWITTER_POST_GENERATION:\n        parseBooleanFromText(\n          runtime.getSetting('ENABLE_TWITTER_POST_GENERATION') ||\n            process.env.ENABLE_TWITTER_POST_GENERATION,\n        ) ?? true,\n\n      // int in minutes\n      POST_INTERVAL_MIN: safeParseInt(\n        runtime.getSetting('POST_INTERVAL_MIN') ||\n          process.env.POST_INTERVAL_MIN,\n        90, // 1.5 hours\n      ),\n\n      // int in minutes\n      POST_INTERVAL_MAX: safeParseInt(\n        runtime.getSetting('POST_INTERVAL_MAX') ||\n          process.env.POST_INTERVAL_MAX,\n        180, // 3 hours\n      ),\n\n      // bool\n      ENABLE_ACTION_PROCESSING:\n        parseBooleanFromText(\n          runtime.getSetting('ENABLE_ACTION_PROCESSING') ||\n            process.env.ENABLE_ACTION_PROCESSING,\n        ) ?? false,\n\n      // init in minutes (min 1m)\n      ACTION_INTERVAL: safeParseInt(\n        runtime.getSetting('ACTION_INTERVAL') || process.env.ACTION_INTERVAL,\n        5, // 5 minutes\n      ),\n\n      // bool\n      POST_IMMEDIATELY:\n        parseBooleanFromText(\n          runtime.getSetting('POST_IMMEDIATELY') ||\n            process.env.POST_IMMEDIATELY,\n        ) ?? false,\n\n      TWITTER_SPACES_ENABLE:\n        parseBooleanFromText(\n          runtime.getSetting('TWITTER_SPACES_ENABLE') ||\n            process.env.TWITTER_SPACES_ENABLE,\n        ) ?? false,\n\n      MAX_ACTIONS_PROCESSING: safeParseInt(\n        runtime.getSetting('MAX_ACTIONS_PROCESSING') ||\n          process.env.MAX_ACTIONS_PROCESSING,\n        1,\n      ),\n\n      ACTION_TIMELINE_TYPE:\n        runtime.getSetting('ACTION_TIMELINE_TYPE') ||\n        process.env.ACTION_TIMELINE_TYPE,\n\n      TWITTER_HTTP_PROXY:\n        runtime.getSetting('TWITTER_HTTP_PROXY') ||\n        process.env.TWITTER_HTTP_PROXY,\n\n      // cookies settings\n      TWITTER_COOKIES_AUTH_TOKEN:\n        runtime.getSetting('TWITTER_COOKIES_AUTH_TOKEN') ||\n        process.env.TWITTER_COOKIES_AUTH_TOKEN,\n\n      TWITTER_COOKIES_CT0:\n        runtime.getSetting('TWITTER_COOKIES_CT0') ||\n        process.env.TWITTER_COOKIES_CT0,\n\n      TWITTER_COOKIES_GUEST_ID:\n        runtime.getSetting('TWITTER_COOKIES_GUEST_ID') ||\n        process.env.TWITTER_COOKIES_GUEST_ID,\n    };\n\n    return twitterEnvSchema.parse(twitterConfig);\n  } catch (error) {\n    if (error instanceof ZodError) {\n      const errorMessages = error.errors\n        .map((err) => `${err.path.join('.')}: ${err.message}`)\n        .join('\\n');\n      throw new Error(\n        `X/Twitter configuration validation failed:\\n${errorMessages}`,\n      );\n    }\n    throw error;\n  }\n}\n","import { SearchMode, type Tweet } from 'agent-twitter-client';\nimport {\n  composeContext,\n  generateMessageResponse,\n  generateShouldRespond,\n  messageCompletionFooter,\n  shouldRespondFooter,\n  type Content,\n  type HandlerCallback,\n  type IAgentRuntime,\n  type Memory,\n  ModelClass,\n  type State,\n  stringToUuid,\n  getEmbeddingZeroVector,\n  type IImageDescriptionService,\n  ServiceType,\n} from '@elizaos/core';\nimport type { ClientBase } from './base';\nimport { buildConversationThread, sendTweet, wait } from './utils.js';\nimport pino from 'pino';\n\nexport const twitterMessageHandlerTemplate =\n  `\n# Areas of Expertise\n{{knowledge}}\n\n# About {{agentName}} (@{{twitterUserName}}):\n{{bio}}\n{{lore}}\n{{topics}}\n\n{{providers}}\n\n{{characterPostExamples}}\n\n{{postDirections}}\n\nRecent interactions between {{agentName}} and other users:\n{{recentPostInteractions}}\n\n{{recentPosts}}\n\n# TASK: Generate a post/reply in the voice, style and perspective of {{agentName}} (@{{twitterUserName}}) while using the thread of tweets as additional context:\n\nCurrent Post:\n{{currentPost}}\nHere is the descriptions of images in the Current post.\n{{imageDescriptions}}\n\nThread of Tweets You Are Replying To:\n{{formattedConversation}}\n\n# INSTRUCTIONS: Generate a post in the voice, style and perspective of {{agentName}} (@{{twitterUserName}}). You MUST include an action if the current post text includes a prompt that is similar to one of the available actions mentioned here:\n{{actionNames}}\n{{actions}}\n\nHere is the current post text again. Remember to include an action if the current post text includes a prompt that asks for one of the available actions mentioned above (does not need to be exact)\n{{currentPost}}\nHere is the descriptions of images in the Current post.\n{{imageDescriptions}}\n` + messageCompletionFooter;\n\nexport const twitterShouldRespondTemplate = (targetUsersStr: string) =>\n  `# INSTRUCTIONS: Determine if {{agentName}} (@{{twitterUserName}}) should respond to the message and participate in the conversation. Do not comment. Just respond with \"true\" or \"false\".\n\nResponse options are RESPOND, IGNORE and STOP.\n\nPRIORITY RULE: ALWAYS RESPOND to these users regardless of topic or message content: ${targetUsersStr}. Topic relevance should be ignored for these users.\n\nFor other users:\n- {{agentName}} should RESPOND to messages directed at them\n- {{agentName}} should RESPOND to conversations relevant to their background\n- {{agentName}} should IGNORE irrelevant messages\n- {{agentName}} should IGNORE very short messages unless directly addressed\n- {{agentName}} should STOP if asked to stop\n- {{agentName}} should STOP if conversation is concluded\n- {{agentName}} is in a room with other users and wants to be conversational, but not annoying.\n\nIMPORTANT:\n- {{agentName}} (aka @{{twitterUserName}}) is particularly sensitive about being annoying, so if there is any doubt, it is better to IGNORE than to RESPOND.\n- For users not in the priority list, {{agentName}} (@{{twitterUserName}}) should err on the side of IGNORE rather than RESPOND if in doubt.\n\nRecent Posts:\n{{recentPosts}}\n\nCurrent Post:\n{{currentPost}}\n\nThread of Tweets You Are Replying To:\n{{formattedConversation}}\n\n# INSTRUCTIONS: Respond with [RESPOND] if {{agentName}} should respond, or [IGNORE] if {{agentName}} should not respond to the last message and [STOP] if {{agentName}} should stop participating in the conversation.\n` + shouldRespondFooter;\n\nexport class TwitterInteractionClient {\n  client: ClientBase;\n  runtime: IAgentRuntime;\n  private isDryRun: boolean;\n  private handleTwitterInteractionsInterval: NodeJS.Timeout;\n  private logger: pino.Logger<string, boolean>;\n\n  constructor(client: ClientBase, runtime: IAgentRuntime) {\n    this.client = client;\n    this.runtime = runtime;\n    this.isDryRun = this.client.twitterConfig.TWITTER_DRY_RUN;\n    this.logger = client.logger;\n  }\n\n  async start() {\n    this.handleTwitterInteractionsInterval = setInterval(async () => {\n      await this.handleTwitterInteractions();\n    }, this.client.twitterConfig.TWITTER_POLL_INTERVAL * 1000);\n  }\n\n  async stop() {\n    if (this.handleTwitterInteractionsInterval) {\n      clearInterval(this.handleTwitterInteractionsInterval);\n      this.handleTwitterInteractionsInterval = null;\n      const twitterUsername = this.client.twitterConfig.TWITTER_USERNAME;\n      this.logger.info(\n        `${twitterUsername} task handleTwitterInteractions stopped`,\n      );\n    }\n\n    return true;\n  }\n\n  async handleTwitterInteractions() {\n    this.logger.log('Checking Twitter interactions');\n\n    const twitterUsername = this.client.profile.username;\n    try {\n      // Check for mentions\n      const mentionCandidates = (\n        await this.client.fetchSearchTweets(\n          `@${twitterUsername}`,\n          20,\n          SearchMode.Latest,\n        )\n      ).tweets;\n\n      this.logger.log(\n        'Completed checking mentioned tweets:',\n        mentionCandidates.length,\n      );\n      let uniqueTweetCandidates = [...mentionCandidates];\n      // Only process target users if configured\n      if (this.client.twitterConfig.TWITTER_TARGET_USERS.length) {\n        const TARGET_USERS = this.client.twitterConfig.TWITTER_TARGET_USERS;\n\n        this.logger.log('Processing target users:', TARGET_USERS);\n\n        if (TARGET_USERS.length > 0) {\n          // Create a map to store tweets by user\n          const tweetsByUser = new Map<string, Tweet[]>();\n\n          // Fetch tweets from all target users\n          for (const username of TARGET_USERS) {\n            try {\n              const userTweets = (\n                await this.client.twitterClient.fetchSearchTweets(\n                  `from:${username}`,\n                  3,\n                  SearchMode.Latest,\n                )\n              ).tweets;\n\n              // Filter for unprocessed, non-reply, recent tweets\n              const validTweets = userTweets.filter((tweet) => {\n                const isUnprocessed =\n                  !this.client.lastCheckedTweetId ||\n                  Number.parseInt(tweet.id) > this.client.lastCheckedTweetId;\n                const isRecent =\n                  Date.now() - tweet.timestamp * 1000 < 2 * 60 * 60 * 1000;\n\n                this.logger.log(`Tweet ${tweet.id} checks:`, {\n                  isUnprocessed,\n                  isRecent,\n                  isReply: tweet.isReply,\n                  isRetweet: tweet.isRetweet,\n                });\n\n                return (\n                  isUnprocessed &&\n                  !tweet.isReply &&\n                  !tweet.isRetweet &&\n                  isRecent\n                );\n              });\n\n              if (validTweets.length > 0) {\n                tweetsByUser.set(username, validTweets);\n                this.logger.log(\n                  `Found ${validTweets.length} valid tweets from ${username}`,\n                );\n              }\n            } catch (error) {\n              this.logger.error(\n                `Error fetching tweets for ${username}:`,\n                error,\n              );\n              continue;\n            }\n          }\n\n          // Select one tweet from each user that has tweets\n          const selectedTweets: Tweet[] = [];\n          for (const [username, tweets] of tweetsByUser) {\n            if (tweets.length > 0) {\n              // Randomly select one tweet from this user\n              const randomTweet =\n                tweets[Math.floor(Math.random() * tweets.length)];\n              selectedTweets.push(randomTweet);\n              this.logger.log(\n                `Selected tweet from ${username}: ${randomTweet.text?.substring(0, 100)}`,\n              );\n            }\n          }\n\n          // Add selected tweets to candidates\n          uniqueTweetCandidates = [...mentionCandidates, ...selectedTweets];\n        }\n      } else {\n        this.logger.log('No target users configured, processing only mentions');\n      }\n\n      // Sort tweet candidates by ID in ascending order\n      uniqueTweetCandidates\n        .sort((a, b) => a.id.localeCompare(b.id))\n        .filter((tweet) => tweet.userId !== this.client.profile.id);\n\n      // for each tweet candidate, handle the tweet\n      for (const tweet of uniqueTweetCandidates) {\n        if (\n          !this.client.lastCheckedTweetId ||\n          BigInt(tweet.id) > this.client.lastCheckedTweetId\n        ) {\n          // Generate the tweetId UUID the same way it's done in handleTweet\n          const tweetId = stringToUuid(tweet.id + '-' + this.runtime.agentId);\n\n          // Check if we've already processed this tweet\n          const existingResponse =\n            await this.runtime.messageManager.getMemoryById(tweetId);\n\n          if (existingResponse) {\n            this.logger.log(`Already responded to tweet ${tweet.id}, skipping`);\n            continue;\n          }\n          this.logger.log('New Tweet found', tweet.permanentUrl);\n\n          const roomId = stringToUuid(\n            tweet.conversationId + '-' + this.runtime.agentId,\n          );\n\n          const userIdUUID =\n            tweet.userId === this.client.profile.id\n              ? this.runtime.agentId\n              : stringToUuid(tweet.userId!);\n\n          await this.runtime.ensureConnection(\n            userIdUUID,\n            roomId,\n            tweet.username,\n            tweet.name,\n            'twitter',\n          );\n\n          const thread = await buildConversationThread(tweet, this.client);\n\n          const message = {\n            content: {\n              text: tweet.text,\n              imageUrls: tweet.photos?.map((photo) => photo.url) || [],\n            },\n            agentId: this.runtime.agentId,\n            userId: userIdUUID,\n            roomId,\n          };\n\n          await this.handleTweet({\n            tweet,\n            message,\n            thread,\n          });\n\n          // Update the last checked tweet ID after processing each tweet\n          this.client.lastCheckedTweetId = BigInt(tweet.id);\n        }\n      }\n\n      // Save the latest checked tweet ID to the file\n      await this.client.cacheLatestCheckedTweetId();\n\n      this.logger.log('Finished checking Twitter interactions');\n    } catch (error) {\n      this.logger.error(error);\n      this.logger.error(`Error handling Twitter interactions: ${error}`);\n    }\n  }\n\n  private async handleTweet({\n    tweet,\n    message,\n    thread,\n  }: {\n    tweet: Tweet;\n    message: Memory;\n    thread: Tweet[];\n  }) {\n    // Only skip if tweet is from self AND not from a target user\n    if (\n      tweet.userId === this.client.profile.id &&\n      !this.client.twitterConfig.TWITTER_TARGET_USERS.includes(tweet.username)\n    ) {\n      return;\n    }\n\n    if (!message.content.text) {\n      this.logger.log('Skipping Tweet with no text', tweet.id);\n      return { text: '', action: 'IGNORE' };\n    }\n\n    this.logger.log('Processing Tweet: ', tweet.id);\n    const formatTweet = (tweet: Tweet) => {\n      return `  ID: ${tweet.id}\n  From: ${tweet.name} (@${tweet.username})\n  Text: ${tweet.text}`;\n    };\n    const currentPost = formatTweet(tweet);\n\n    const formattedConversation = thread\n      .map(\n        (tweet) => `@${tweet.username} (${new Date(\n          tweet.timestamp * 1000,\n        ).toLocaleString('en-US', {\n          hour: '2-digit',\n          minute: '2-digit',\n          month: 'short',\n          day: 'numeric',\n        })}):\n        ${tweet.text}`,\n      )\n      .join('\\n\\n');\n\n    const imageDescriptionsArray = [];\n    try {\n      for (const photo of tweet.photos) {\n        const description = await this.runtime\n          .getService<IImageDescriptionService>(ServiceType.IMAGE_DESCRIPTION)\n          .describeImage(photo.url);\n        imageDescriptionsArray.push(description);\n      }\n    } catch (error) {\n      // Handle the error\n      this.logger.error('Error Occured during describing image: ', error);\n    }\n\n    let state = await this.runtime.composeState(message, {\n      twitterClient: this.client.twitterClient,\n      twitterUserName: this.client.twitterConfig.TWITTER_USERNAME,\n      currentPost,\n      formattedConversation,\n      imageDescriptions:\n        imageDescriptionsArray.length > 0\n          ? `\\nImages in Tweet:\\n${imageDescriptionsArray\n              .map(\n                (desc, i) =>\n                  `Image ${i + 1}: Title: ${desc.title}\\nDescription: ${desc.description}`,\n              )\n              .join('\\n\\n')}`\n          : '',\n    });\n\n    // check if the tweet exists, save if it doesn't\n    const tweetId = stringToUuid(tweet.id + '-' + this.runtime.agentId);\n    const tweetExists =\n      await this.runtime.messageManager.getMemoryById(tweetId);\n\n    if (!tweetExists) {\n      this.logger.log('tweet does not exist, saving');\n      const userIdUUID = stringToUuid(tweet.userId as string);\n      const roomId = stringToUuid(tweet.conversationId);\n\n      const message = {\n        id: tweetId,\n        agentId: this.runtime.agentId,\n        content: {\n          text: tweet.text,\n          url: tweet.permanentUrl,\n          imageUrls: tweet.photos?.map((photo) => photo.url) || [],\n          inReplyTo: tweet.inReplyToStatusId\n            ? stringToUuid(tweet.inReplyToStatusId + '-' + this.runtime.agentId)\n            : undefined,\n        },\n        userId: userIdUUID,\n        roomId,\n        createdAt: tweet.timestamp * 1000,\n      };\n      this.client.saveRequestMessage(message, state);\n    }\n\n    // get usernames into str\n    const validTargetUsersStr =\n      this.client.twitterConfig.TWITTER_TARGET_USERS.join(',');\n\n    const shouldRespondContext = composeContext({\n      state,\n      template:\n        this.runtime.character.templates?.twitterShouldRespondTemplate ||\n        this.runtime.character?.templates?.shouldRespondTemplate ||\n        twitterShouldRespondTemplate(validTargetUsersStr),\n    });\n\n    const shouldRespond = await generateShouldRespond({\n      runtime: this.runtime,\n      context: shouldRespondContext,\n      modelClass: ModelClass.MEDIUM,\n    });\n\n    // Promise<\"RESPOND\" | \"IGNORE\" | \"STOP\" | null> {\n    if (shouldRespond !== 'RESPOND') {\n      this.logger.log('Not responding to message');\n      return { text: 'Response Decision:', action: shouldRespond };\n    }\n\n    const context = composeContext({\n      state: {\n        ...state,\n        // Convert actionNames array to string\n        actionNames: Array.isArray(state.actionNames)\n          ? state.actionNames.join(', ')\n          : state.actionNames || '',\n        actions: Array.isArray(state.actions)\n          ? state.actions.join('\\n')\n          : state.actions || '',\n        // Ensure character examples are included\n        characterPostExamples: this.runtime.character.messageExamples\n          ? this.runtime.character.messageExamples\n              .map((example) =>\n                example\n                  .map(\n                    (msg) =>\n                      `${msg.user}: ${msg.content.text}${msg.content.action ? ` [Action: ${msg.content.action}]` : ''}`,\n                  )\n                  .join('\\n'),\n              )\n              .join('\\n\\n')\n          : '',\n      },\n      template:\n        this.runtime.character.templates?.twitterMessageHandlerTemplate ||\n        this.runtime.character?.templates?.messageHandlerTemplate ||\n        twitterMessageHandlerTemplate,\n    });\n\n    const response = await generateMessageResponse({\n      runtime: this.runtime,\n      context,\n      modelClass: ModelClass.LARGE,\n    });\n\n    const removeQuotes = (str: string) => str.replace(/^['\"](.*)['\"]$/, '$1');\n\n    const stringId = stringToUuid(tweet.id + '-' + this.runtime.agentId);\n\n    response.inReplyTo = stringId;\n\n    response.text = removeQuotes(response.text);\n\n    if (response.text) {\n      if (this.isDryRun) {\n        this.logger.info(\n          `Dry run: Selected Post: ${tweet.id} - ${tweet.username}: ${tweet.text}\\nAgent's Output:\\n${response.text}`,\n        );\n      } else {\n        try {\n          const callback: HandlerCallback = async (\n            response: Content,\n            tweetId?: string,\n          ) => {\n            const memories = await sendTweet(\n              this.client,\n              response,\n              message.roomId,\n              this.client.twitterConfig.TWITTER_USERNAME,\n              tweetId || tweet.id,\n            );\n            return memories;\n          };\n\n          const action = this.runtime.actions.find(\n            (a) => a.name === response.action,\n          );\n          const shouldSuppressInitialMessage = action?.suppressInitialMessage;\n\n          let responseMessages = [];\n\n          if (!shouldSuppressInitialMessage) {\n            responseMessages = await callback(response);\n          } else {\n            responseMessages = [\n              {\n                id: stringToUuid(tweet.id + '-' + this.runtime.agentId),\n                userId: this.runtime.agentId,\n                agentId: this.runtime.agentId,\n                content: response,\n                roomId: message.roomId,\n                embedding: getEmbeddingZeroVector(),\n                createdAt: Date.now(),\n              },\n            ];\n          }\n\n          state = (await this.runtime.updateRecentMessageState(state)) as State;\n\n          for (const responseMessage of responseMessages) {\n            if (\n              responseMessage === responseMessages[responseMessages.length - 1]\n            ) {\n              responseMessage.content.action = response.action;\n            } else {\n              responseMessage.content.action = 'CONTINUE';\n            }\n            await this.runtime.messageManager.createMemory(responseMessage);\n          }\n\n          const responseTweetId =\n            responseMessages[responseMessages.length - 1]?.content?.tweetId;\n\n          await this.runtime.processActions(\n            message,\n            responseMessages,\n            state,\n            (response: Content) => {\n              return callback(response, responseTweetId);\n            },\n          );\n\n          const responseInfo = `Context:\\n\\n${context}\\n\\nSelected Post: ${tweet.id} - ${tweet.username}: ${tweet.text}\\nAgent's Output:\\n${response.text}`;\n\n          await this.runtime.cacheManager.set(\n            `twitter/tweet_generation_${tweet.id}.txt`,\n            responseInfo,\n          );\n          await wait();\n        } catch (error) {\n          this.logger.error(`Error sending response tweet: ${error}`);\n        }\n      }\n    }\n  }\n\n  async buildConversationThread(\n    tweet: Tweet,\n    maxReplies = 10,\n  ): Promise<Tweet[]> {\n    const thread: Tweet[] = [];\n    const visited: Set<string> = new Set();\n\n    async function processThread(currentTweet: Tweet, depth = 0) {\n      this.logger.log('Processing tweet:', {\n        id: currentTweet.id,\n        inReplyToStatusId: currentTweet.inReplyToStatusId,\n        depth: depth,\n      });\n\n      if (!currentTweet) {\n        this.logger.log('No current tweet found for thread building');\n        return;\n      }\n\n      if (depth >= maxReplies) {\n        this.logger.log('Reached maximum reply depth', depth);\n        return;\n      }\n\n      // Handle memory storage\n      const memory = await this.runtime.messageManager.getMemoryById(\n        stringToUuid(currentTweet.id + '-' + this.runtime.agentId),\n      );\n      if (!memory) {\n        const roomId = stringToUuid(\n          currentTweet.conversationId + '-' + this.runtime.agentId,\n        );\n        const userId = stringToUuid(currentTweet.userId);\n\n        await this.runtime.ensureConnection(\n          userId,\n          roomId,\n          currentTweet.username,\n          currentTweet.name,\n          'twitter',\n        );\n\n        this.runtime.messageManager.createMemory({\n          id: stringToUuid(currentTweet.id + '-' + this.runtime.agentId),\n          agentId: this.runtime.agentId,\n          content: {\n            text: currentTweet.text,\n            source: 'twitter',\n            url: currentTweet.permanentUrl,\n            imageUrls: currentTweet.photos?.map((photo) => photo.url) || [],\n            inReplyTo: currentTweet.inReplyToStatusId\n              ? stringToUuid(\n                  currentTweet.inReplyToStatusId + '-' + this.runtime.agentId,\n                )\n              : undefined,\n          },\n          createdAt: currentTweet.timestamp * 1000,\n          roomId,\n          userId:\n            currentTweet.userId === this.twitterUserId\n              ? this.runtime.agentId\n              : stringToUuid(currentTweet.userId),\n          embedding: getEmbeddingZeroVector(),\n        });\n      }\n\n      if (visited.has(currentTweet.id)) {\n        this.logger.log('Already visited tweet:', currentTweet.id);\n        return;\n      }\n\n      visited.add(currentTweet.id);\n      thread.unshift(currentTweet);\n\n      if (currentTweet.inReplyToStatusId) {\n        this.logger.log(\n          'Fetching parent tweet:',\n          currentTweet.inReplyToStatusId,\n        );\n        try {\n          const parentTweet = await this.twitterClient.getTweet(\n            currentTweet.inReplyToStatusId,\n          );\n\n          if (parentTweet) {\n            this.logger.log('Found parent tweet:', {\n              id: parentTweet.id,\n              text: parentTweet.text?.slice(0, 50),\n            });\n            await processThread(parentTweet, depth + 1);\n          } else {\n            this.logger.log(\n              'No parent tweet found for:',\n              currentTweet.inReplyToStatusId,\n            );\n          }\n        } catch (error) {\n          this.logger.log('Error fetching parent tweet:', {\n            tweetId: currentTweet.inReplyToStatusId,\n            error,\n          });\n        }\n      } else {\n        this.logger.log('Reached end of reply chain at:', currentTweet.id);\n      }\n    }\n\n    // Need to bind this context for the inner function\n    await processThread.bind(this)(tweet, 0);\n\n    return thread;\n  }\n}\n","import type { Tweet } from 'agent-twitter-client';\nimport { getEmbeddingZeroVector } from '@elizaos/core';\nimport type { Content, Memory, UUID } from '@elizaos/core';\nimport { stringToUuid } from '@elizaos/core';\nimport type { ClientBase } from './base';\nimport { elizaLogger } from '@elizaos/core';\nimport type { Media } from '@elizaos/core';\nimport fs from 'fs';\nimport path from 'path';\nimport { MediaData } from './types';\n\nexport const wait = (minTime = 1000, maxTime = 3000) => {\n  const waitTime =\n    Math.floor(Math.random() * (maxTime - minTime + 1)) + minTime;\n  return new Promise((resolve) => setTimeout(resolve, waitTime));\n};\n\nexport const isValidTweet = (tweet: Tweet): boolean => {\n  // Filter out tweets with too many hashtags, @s, or $ signs, probably spam or garbage\n  const hashtagCount = (tweet.text?.match(/#/g) || []).length;\n  const atCount = (tweet.text?.match(/@/g) || []).length;\n  const dollarSignCount = (tweet.text?.match(/\\$/g) || []).length;\n  const totalCount = hashtagCount + atCount + dollarSignCount;\n\n  return (\n    hashtagCount <= 1 && atCount <= 2 && dollarSignCount <= 1 && totalCount <= 3\n  );\n};\n\nexport async function buildConversationThread(\n  tweet: Tweet,\n  client: ClientBase,\n  maxReplies = 10,\n): Promise<Tweet[]> {\n  const thread: Tweet[] = [];\n  const visited: Set<string> = new Set();\n\n  async function processThread(currentTweet: Tweet, depth = 0) {\n    elizaLogger.debug('Processing tweet:', {\n      id: currentTweet.id,\n      inReplyToStatusId: currentTweet.inReplyToStatusId,\n      depth: depth,\n    });\n\n    if (!currentTweet) {\n      elizaLogger.debug('No current tweet found for thread building');\n      return;\n    }\n\n    // Stop if we've reached our reply limit\n    if (depth >= maxReplies) {\n      elizaLogger.debug('Reached maximum reply depth', depth);\n      return;\n    }\n\n    // Handle memory storage\n    const memory = await client.runtime.messageManager.getMemoryById(\n      stringToUuid(currentTweet.id + '-' + client.runtime.agentId),\n    );\n    if (!memory) {\n      const roomId = stringToUuid(\n        currentTweet.conversationId + '-' + client.runtime.agentId,\n      );\n      const userId = stringToUuid(currentTweet.userId);\n\n      await client.runtime.ensureConnection(\n        userId,\n        roomId,\n        currentTweet.username,\n        currentTweet.name,\n        'twitter',\n      );\n\n      await client.runtime.messageManager.createMemory({\n        id: stringToUuid(currentTweet.id + '-' + client.runtime.agentId),\n        agentId: client.runtime.agentId,\n        content: {\n          text: currentTweet.text,\n          source: 'twitter',\n          url: currentTweet.permanentUrl,\n          imageUrls: currentTweet.photos.map((p) => p.url) || [],\n          inReplyTo: currentTweet.inReplyToStatusId\n            ? stringToUuid(\n                currentTweet.inReplyToStatusId + '-' + client.runtime.agentId,\n              )\n            : undefined,\n        },\n        createdAt: currentTweet.timestamp * 1000,\n        roomId,\n        userId:\n          currentTweet.userId === client.profile.id\n            ? client.runtime.agentId\n            : stringToUuid(currentTweet.userId),\n        embedding: getEmbeddingZeroVector(),\n      });\n    }\n\n    if (visited.has(currentTweet.id)) {\n      elizaLogger.debug('Already visited tweet:', currentTweet.id);\n      return;\n    }\n\n    visited.add(currentTweet.id);\n    thread.unshift(currentTweet);\n\n    elizaLogger.debug('Current thread state:', {\n      length: thread.length,\n      currentDepth: depth,\n      tweetId: currentTweet.id,\n    });\n\n    // If there's a parent tweet, fetch and process it\n    if (currentTweet.inReplyToStatusId) {\n      elizaLogger.debug(\n        'Fetching parent tweet:',\n        currentTweet.inReplyToStatusId,\n      );\n      try {\n        const parentTweet = await client.twitterClient.getTweet(\n          currentTweet.inReplyToStatusId,\n        );\n\n        if (parentTweet) {\n          elizaLogger.debug('Found parent tweet:', {\n            id: parentTweet.id,\n            text: parentTweet.text?.slice(0, 50),\n          });\n          await processThread(parentTweet, depth + 1);\n        } else {\n          elizaLogger.debug(\n            'No parent tweet found for:',\n            currentTweet.inReplyToStatusId,\n          );\n        }\n      } catch (error) {\n        elizaLogger.error('Error fetching parent tweet:', {\n          tweetId: currentTweet.inReplyToStatusId,\n          error,\n        });\n      }\n    } else {\n      elizaLogger.debug('Reached end of reply chain at:', currentTweet.id);\n    }\n  }\n\n  await processThread(tweet, 0);\n\n  elizaLogger.debug('Final thread built:', {\n    totalTweets: thread.length,\n    tweetIds: thread.map((t) => ({\n      id: t.id,\n      text: t.text?.slice(0, 50),\n    })),\n  });\n\n  return thread;\n}\n\nexport async function fetchMediaData(\n  attachments: Media[],\n): Promise<MediaData[]> {\n  return Promise.all(\n    attachments.map(async (attachment: Media) => {\n      if (/^(http|https):\\/\\//.test(attachment.url)) {\n        // Handle HTTP URLs\n        const response = await fetch(attachment.url);\n        if (!response.ok) {\n          throw new Error(`Failed to fetch file: ${attachment.url}`);\n        }\n        const mediaBuffer = Buffer.from(await response.arrayBuffer());\n        const mediaType = attachment.contentType;\n        return { data: mediaBuffer, mediaType };\n      } else if (fs.existsSync(attachment.url)) {\n        // Handle local file paths\n        const mediaBuffer = await fs.promises.readFile(\n          path.resolve(attachment.url),\n        );\n        const mediaType = attachment.contentType;\n        return { data: mediaBuffer, mediaType };\n      } else {\n        throw new Error(\n          `File not found: ${attachment.url}. Make sure the path is correct.`,\n        );\n      }\n    }),\n  );\n}\n\nexport async function sendTweet(\n  client: ClientBase,\n  content: Content,\n  roomId: UUID,\n  twitterUsername: string,\n  inReplyTo: string,\n): Promise<Memory[]> {\n  const maxTweetLength = client.twitterConfig.MAX_TWEET_LENGTH;\n  const isLongTweet = maxTweetLength > 280;\n\n  const tweetChunks = splitTweetContent(content.text, maxTweetLength);\n  const sentTweets: Tweet[] = [];\n  let previousTweetId = inReplyTo;\n\n  for (const chunk of tweetChunks) {\n    let mediaData = null;\n\n    if (content.attachments && content.attachments.length > 0) {\n      mediaData = await fetchMediaData(content.attachments);\n    }\n\n    const cleanChunk = deduplicateMentions(chunk.trim());\n\n    const result = await client.requestQueue.add(async () =>\n      isLongTweet\n        ? client.twitterClient.sendLongTweet(\n            cleanChunk,\n            previousTweetId,\n            mediaData,\n          )\n        : client.twitterClient.sendTweet(\n            cleanChunk,\n            previousTweetId,\n            mediaData,\n          ),\n    );\n\n    const body = await result.json();\n    const tweetResult = isLongTweet\n      ? body?.data?.notetweet_create?.tweet_results?.result\n      : body?.data?.create_tweet?.tweet_results?.result;\n\n    // if we have a response\n    if (tweetResult) {\n      // Parse the response\n      const finalTweet: Tweet = {\n        id: tweetResult.rest_id,\n        text: tweetResult.legacy.full_text,\n        conversationId: tweetResult.legacy.conversation_id_str,\n        timestamp: new Date(tweetResult.legacy.created_at).getTime() / 1000,\n        userId: tweetResult.legacy.user_id_str,\n        inReplyToStatusId: tweetResult.legacy.in_reply_to_status_id_str,\n        permanentUrl: `https://twitter.com/${twitterUsername}/status/${tweetResult.rest_id}`,\n        hashtags: [],\n        mentions: [],\n        photos: [],\n        thread: [],\n        urls: [],\n        videos: [],\n      };\n      sentTweets.push(finalTweet);\n      previousTweetId = finalTweet.id;\n    } else {\n      elizaLogger.error('Error sending tweet chunk:', {\n        chunk,\n        response: body,\n      });\n    }\n\n    // Wait a bit between tweets to avoid rate limiting issues\n    await wait(1000, 2000);\n  }\n\n  const memories: Memory[] = sentTweets.map((tweet) => ({\n    id: stringToUuid(tweet.id + '-' + client.runtime.agentId),\n    agentId: client.runtime.agentId,\n    userId: client.runtime.agentId,\n    content: {\n      tweetId: tweet.id,\n      text: tweet.text,\n      source: 'twitter',\n      url: tweet.permanentUrl,\n      imageUrls: tweet.photos.map((p) => p.url) || [],\n      inReplyTo: tweet.inReplyToStatusId\n        ? stringToUuid(tweet.inReplyToStatusId + '-' + client.runtime.agentId)\n        : undefined,\n    },\n    roomId,\n    embedding: getEmbeddingZeroVector(),\n    createdAt: tweet.timestamp * 1000,\n  }));\n\n  return memories;\n}\n\nfunction splitTweetContent(content: string, maxLength: number): string[] {\n  const paragraphs = content.split('\\n\\n').map((p) => p.trim());\n  const tweets: string[] = [];\n  let currentTweet = '';\n\n  for (const paragraph of paragraphs) {\n    if (!paragraph) continue;\n\n    if ((currentTweet + '\\n\\n' + paragraph).trim().length <= maxLength) {\n      if (currentTweet) {\n        currentTweet += '\\n\\n' + paragraph;\n      } else {\n        currentTweet = paragraph;\n      }\n    } else {\n      if (currentTweet) {\n        tweets.push(currentTweet.trim());\n      }\n      if (paragraph.length <= maxLength) {\n        currentTweet = paragraph;\n      } else {\n        // Split long paragraph into smaller chunks\n        const chunks = splitParagraph(paragraph, maxLength);\n        tweets.push(...chunks.slice(0, -1));\n        currentTweet = chunks[chunks.length - 1];\n      }\n    }\n  }\n\n  if (currentTweet) {\n    tweets.push(currentTweet.trim());\n  }\n\n  return tweets;\n}\n\nfunction extractUrls(paragraph: string): {\n  textWithPlaceholders: string;\n  placeholderMap: Map<string, string>;\n} {\n  // replace https urls with placeholder\n  const urlRegex = /https?:\\/\\/[^\\s]+/g;\n  const placeholderMap = new Map<string, string>();\n\n  let urlIndex = 0;\n  const textWithPlaceholders = paragraph.replace(urlRegex, (match) => {\n    // twitter url would be considered as 23 characters\n    // <<URL_CONSIDERER_23_1>> is also 23 characters\n    const placeholder = `<<URL_CONSIDERER_23_${urlIndex}>>`; // Placeholder without . ? ! etc\n    placeholderMap.set(placeholder, match);\n    urlIndex++;\n    return placeholder;\n  });\n\n  return { textWithPlaceholders, placeholderMap };\n}\n\nfunction splitSentencesAndWords(text: string, maxLength: number): string[] {\n  // Split by periods, question marks and exclamation marks\n  // Note that URLs in text have been replaced with `<<URL_xxx>>` and won't be split by dots\n  const sentences = text.match(/[^.!?]+[.!?]+|[^.!?]+$/g) || [text];\n  const chunks: string[] = [];\n  let currentChunk = '';\n\n  for (const sentence of sentences) {\n    if ((currentChunk + ' ' + sentence).trim().length <= maxLength) {\n      if (currentChunk) {\n        currentChunk += ' ' + sentence;\n      } else {\n        currentChunk = sentence;\n      }\n    } else {\n      // Can't fit more, push currentChunk to results\n      if (currentChunk) {\n        chunks.push(currentChunk.trim());\n      }\n\n      // If current sentence itself is less than or equal to maxLength\n      if (sentence.length <= maxLength) {\n        currentChunk = sentence;\n      } else {\n        // Need to split sentence by spaces\n        const words = sentence.split(' ');\n        currentChunk = '';\n        for (const word of words) {\n          if ((currentChunk + ' ' + word).trim().length <= maxLength) {\n            if (currentChunk) {\n              currentChunk += ' ' + word;\n            } else {\n              currentChunk = word;\n            }\n          } else {\n            if (currentChunk) {\n              chunks.push(currentChunk.trim());\n            }\n            currentChunk = word;\n          }\n        }\n      }\n    }\n  }\n\n  // Handle remaining content\n  if (currentChunk) {\n    chunks.push(currentChunk.trim());\n  }\n\n  return chunks;\n}\n\nfunction deduplicateMentions(paragraph: string) {\n  // Regex to match mentions at the beginning of the string\n  const mentionRegex = /^@(\\w+)(?:\\s+@(\\w+))*(\\s+|$)/;\n\n  // Find all matches\n  const matches = paragraph.match(mentionRegex);\n\n  if (!matches) {\n    return paragraph; // If no matches, return the original string\n  }\n\n  // Extract mentions from the match groups\n  let mentions = matches.slice(0, 1)[0].trim().split(' ');\n\n  // Deduplicate mentions\n  mentions = [...new Set(mentions)];\n\n  // Reconstruct the string with deduplicated mentions\n  const uniqueMentionsString = mentions.join(' ');\n\n  // Find where the mentions end in the original string\n  const endOfMentions = paragraph.indexOf(matches[0]) + matches[0].length;\n\n  // Construct the result by combining unique mentions with the rest of the string\n  return uniqueMentionsString + ' ' + paragraph.slice(endOfMentions);\n}\n\nfunction restoreUrls(\n  chunks: string[],\n  placeholderMap: Map<string, string>,\n): string[] {\n  return chunks.map((chunk) => {\n    // Replace all <<URL_CONSIDERER_23_>> in chunk back to original URLs using regex\n    return chunk.replace(/<<URL_CONSIDERER_23_(\\d+)>>/g, (match) => {\n      const original = placeholderMap.get(match);\n      return original || match; // Return placeholder if not found (theoretically won't happen)\n    });\n  });\n}\n\nfunction splitParagraph(paragraph: string, maxLength: number): string[] {\n  // 1) Extract URLs and replace with placeholders\n  const { textWithPlaceholders, placeholderMap } = extractUrls(paragraph);\n\n  // 2) Use first section's logic to split by sentences first, then do secondary split\n  const splittedChunks = splitSentencesAndWords(\n    textWithPlaceholders,\n    maxLength,\n  );\n\n  // 3) Replace placeholders back to original URLs\n  const restoredChunks = restoreUrls(splittedChunks, placeholderMap);\n\n  return restoredChunks;\n}\n","import { type Tweet } from 'agent-twitter-client';\nimport {\n  composeContext,\n  generateText,\n  getEmbeddingZeroVector,\n  type IAgentRuntime,\n  ModelClass,\n  stringToUuid,\n  type TemplateType,\n  type UUID,\n  truncateToCompleteSentence,\n  parseJSONObjectFromText,\n  extractAttributes,\n  cleanJsonResponse,\n} from '@elizaos/core';\nimport type { ClientBase } from './base.js';\nimport { postActionResponseFooter } from '@elizaos/core';\nimport { generateTweetActions } from '@elizaos/core';\nimport { type IImageDescriptionService, ServiceType } from '@elizaos/core';\nimport { buildConversationThread, fetchMediaData } from './utils.js';\nimport { twitterMessageHandlerTemplate } from './interactions.js';\nimport { DEFAULT_MAX_TWEET_LENGTH } from './environment.js';\nimport {\n  Client,\n  Events,\n  GatewayIntentBits,\n  TextChannel,\n  Partials,\n} from 'discord.js';\nimport type { State } from '@elizaos/core';\nimport type { ActionResponse } from '@elizaos/core';\nimport { MediaData } from './types.js';\nimport pino from 'pino';\nimport { twitterPostCount } from './monitor/metrics.js';\nimport { Logger } from './settings/index.js';\n\nconst MAX_TIMELINES_TO_FETCH = 15;\n\nconst twitterPostTemplate = `\n# Areas of Expertise\n{{knowledge}}\n\n# About {{agentName}} (@{{twitterUserName}}):\n{{bio}}\n{{lore}}\n{{topics}}\n\n{{providers}}\n\n{{characterPostExamples}}\n\n{{postDirections}}\n\n# Task: Generate a post in the voice and style and perspective of {{agentName}} @{{twitterUserName}}.\nWrite a post that is {{adjective}} about {{topic}} (without mentioning {{topic}} directly), from the perspective of {{agentName}}. Do not add commentary or acknowledge this request, just write the post.\nYour response should be 1, 2, or 3 sentences (choose the length at random).\nYour response should not contain any questions. Brief, concise statements only. The total character count MUST be less than {{maxTweetLength}}. No emojis. Use \\\\n\\\\n (double spaces) between statements if there are multiple statements in your response.`;\n\nexport const twitterActionTemplate =\n  `\n# INSTRUCTIONS: Determine actions for {{agentName}} (@{{twitterUserName}}) based on:\n{{bio}}\n{{postDirections}}\n\nGuidelines:\n- ONLY engage with content that DIRECTLY relates to character's core interests\n- Direct mentions are priority IF they are on-topic\n- Skip ALL content that is:\n  - Off-topic or tangentially related\n  - From high-profile accounts unless explicitly relevant\n  - Generic/viral content without specific relevance\n  - Political/controversial unless central to character\n  - Promotional/marketing unless directly relevant\n\nActions (respond only with tags):\n[LIKE] - Perfect topic match AND aligns with character (9.8/10)\n[RETWEET] - Exceptional content that embodies character's expertise (9.5/10)\n[QUOTE] - Can add substantial domain expertise (9.5/10)\n[REPLY] - Can contribute meaningful, expert-level insight (9.5/10)\n\nTweet:\n{{currentTweet}}\n\n# Respond with qualifying action tags only. Default to NO action unless extremely confident of relevance.` +\n  postActionResponseFooter;\n\ninterface PendingTweet {\n  tweetTextForPosting: string;\n  roomId: UUID;\n  rawTweetContent: string;\n  discordMessageId: string;\n  channelId: string;\n  timestamp: number;\n}\n\ntype PendingTweetApprovalStatus = 'PENDING' | 'APPROVED' | 'REJECTED';\n\nclass RuntimeTwitterPostHelper {\n  constructor(private runtime: IAgentRuntime, private logger: pino.Logger<string, boolean>) {}\n\n  /**\n * Generates and posts a new tweet. If isDryRun is true, only logs what would have been posted.\n */\n  async generatePostTweet(username: string, max_tweet_length: number) {\n    const roomId = stringToUuid('twitter_generate_room-' + username,);\n    const topics = this.runtime.character.topics.join(', ');\n    // it's better to using 4/5 MAX_LEN to prevent reach the limit\n    const maxTweetLength = Math.floor((max_tweet_length * 4) / 5);\n\n    let tokenTweets: {\n      symbol: string;\n      tweetContents: string[];\n    };\n    if (this.runtime.character.topics.includes('crypto currency news')) {\n      const trendingTokens = await getTrendingTokens(\n        this.runtime.getSetting('BIRDEYE_API_KEY'),\n      );\n      for (const item of trendingTokens) {\n        const itemKey = 'token:analysis:' + item.symbol;\n        const postTime: number | undefined =\n          await this.runtime.cacheManager.get(itemKey);\n        if (postTime && Date.now() - postTime < 1000 * 60 * 60 * 12) {\n          continue;\n        }\n        const pumpNewsApikey =\n          this.runtime.getSetting('PUMPNEWS_API_KEY') ||\n          process.env?.PUMPNEWS_API_KEY;\n        const tweets = await fetchPumpNews(pumpNewsApikey, item.address);\n        if (!tweets || tweets.length < 8) {\n          continue;\n        }\n        tokenTweets = {\n          symbol: item.symbol,\n          tweetContents: tweets.map((tweet) => tweet.text),\n        };\n        Logger.log(\n          `Found trending token:, ${item.symbol} with ${tweets.length} tweets`,\n        );\n        await this.runtime.cacheManager.set(itemKey, Date.now());\n        break;\n      }\n    }\n\n    const state = await this.runtime.composeState(\n      {\n        userId: this.runtime.agentId,\n        roomId: roomId,\n        agentId: this.runtime.agentId,\n        content: {\n          text: topics || '',\n          action: 'TWEET',\n        },\n      },\n      {\n        twitterUserName: username,\n        maxTweetLength,\n        tokenSymbol: tokenTweets?.symbol,\n        tweetContents: tokenTweets?.tweetContents,\n      },\n    );\n\n    const context = composeContext({\n      state,\n      template:\n        this.runtime.character.templates?.twitterPostTemplate ||\n        twitterPostTemplate,\n    });\n\n    this.logger.debug('generate post prompt:\\n' + context);\n\n    const response = await generateText({\n      runtime: this.runtime,\n      context,\n      modelClass: ModelClass.SMALL,\n    });\n\n    const rawTweetContent = cleanJsonResponse(response);\n\n    // First attempt to clean content\n    let tweetTextForPosting = null;\n    let mediaData = null;\n\n    // Try parsing as JSON first\n    const parsedResponse = parseJSONObjectFromText(rawTweetContent);\n    if (parsedResponse?.text) {\n      tweetTextForPosting = parsedResponse.text;\n    } else {\n      // If not JSON, use the raw text directly\n      tweetTextForPosting = rawTweetContent.trim();\n    }\n\n    if (\n      parsedResponse?.attachments &&\n      parsedResponse?.attachments.length > 0\n    ) {\n      mediaData = await fetchMediaData(parsedResponse.attachments);\n    }\n\n    // Try extracting text attribute\n    if (!tweetTextForPosting) {\n      const parsingText = extractAttributes(rawTweetContent, ['text']).text;\n      if (parsingText) {\n        tweetTextForPosting = truncateToCompleteSentence(\n          extractAttributes(rawTweetContent, ['text']).text,\n          max_tweet_length,\n        );\n      }\n    }\n\n    // Use the raw text\n    if (!tweetTextForPosting) {\n      tweetTextForPosting = rawTweetContent;\n    }\n\n    // Truncate the content to the maximum tweet length specified in the environment settings, ensuring the truncation respects sentence boundaries.\n    if (maxTweetLength) {\n      tweetTextForPosting = truncateToCompleteSentence(\n        tweetTextForPosting,\n        maxTweetLength,\n      );\n    }\n\n    const removeQuotes = (str: string) => str.replace(/^['\"](.*)['\"]$/, '$1');\n\n    const fixNewLines = (str: string) => str.replaceAll(/\\\\n/g, '\\n\\n'); //ensures double spaces\n\n    // Final cleaning\n    tweetTextForPosting = removeQuotes(fixNewLines(tweetTextForPosting));\n\n    return { tweetTextForPosting, rawTweetContent, mediaData, roomId };\n  }\n}\n\nexport class TwitterPostClient {\n  client: ClientBase;\n  runtime: IAgentRuntime;\n  twitterUsername: string;\n  private isProcessing = false;\n  private lastProcessTime = 0;\n  private isDryRun: boolean;\n  private discordClientForApproval: Client;\n  private approvalRequired = false;\n  private discordApprovalChannelId: string;\n  private approvalCheckInterval: number;\n  private runPendingTweetCheckInterval: NodeJS.Timeout;\n  private runtimeTwitterPostHelper: RuntimeTwitterPostHelper;\n\n  private backendTaskStatus: {\n    // 0 stopped, 1 running, 2 completed\n    generateNewTweet: number;\n    processTweetActions: number;\n    runPendingTweetCheck: number;\n  } = {\n    generateNewTweet: 2,\n    processTweetActions: 2,\n    runPendingTweetCheck: 2,\n  };\n\n  private logger: pino.Logger<string, boolean>;\n\n  constructor(client: ClientBase, runtime: IAgentRuntime) {\n    this.client = client;\n    this.runtime = runtime;\n    this.logger = client.logger;\n    this.twitterUsername = this.client.twitterConfig.TWITTER_USERNAME;\n    this.isDryRun = this.client.twitterConfig.TWITTER_DRY_RUN;\n    this.runtimeTwitterPostHelper = new RuntimeTwitterPostHelper(this.runtime, this.logger);\n\n    // Log configuration on initialization\n    // this.logger.log('Twitter Client Configuration:');\n    // this.logger.log(`- Username: ${this.twitterUsername}`);\n    this.logger.log(\n      `- Dry Run Mode: ${this.isDryRun ? 'enabled' : 'disabled'}`,\n    );\n\n    this.logger.log(\n      `- Enable Post: ${this.client.twitterConfig.ENABLE_TWITTER_POST_GENERATION ? 'enabled' : 'disabled'}`,\n    );\n\n    this.logger.log(\n      `- Post Interval: ${this.client.twitterConfig.POST_INTERVAL_MIN}-${this.client.twitterConfig.POST_INTERVAL_MAX} minutes`,\n    );\n    this.logger.log(\n      `- Action Processing: ${\n        this.client.twitterConfig.ENABLE_ACTION_PROCESSING\n          ? 'enabled'\n          : 'disabled'\n      }`,\n    );\n    this.logger.log(\n      `- Action Interval: ${this.client.twitterConfig.ACTION_INTERVAL} minutes`,\n    );\n    this.logger.log(\n      `- Post Immediately: ${\n        this.client.twitterConfig.POST_IMMEDIATELY ? 'enabled' : 'disabled'\n      }`,\n    );\n    this.logger.log(\n      `- Search Enabled: ${\n        this.client.twitterConfig.TWITTER_SEARCH_ENABLE ? 'enabled' : 'disabled'\n      }`,\n    );\n\n    const targetUsers = this.client.twitterConfig.TWITTER_TARGET_USERS;\n    if (targetUsers) {\n      this.logger.log(`- Target Users: ${targetUsers}`);\n    }\n\n    if (this.isDryRun) {\n      this.logger.log(\n        'Twitter client initialized in dry run mode - no actual tweets should be posted',\n      );\n    }\n\n    // Initialize Discord webhook\n    const approvalRequired: boolean =\n      this.runtime\n        .getSetting('TWITTER_APPROVAL_ENABLED')\n        ?.toLocaleLowerCase() === 'true';\n    if (approvalRequired) {\n      const discordToken = this.runtime.getSetting(\n        'TWITTER_APPROVAL_DISCORD_BOT_TOKEN',\n      );\n      const approvalChannelId = this.runtime.getSetting(\n        'TWITTER_APPROVAL_DISCORD_CHANNEL_ID',\n      );\n\n      const APPROVAL_CHECK_INTERVAL =\n        Number.parseInt(\n          this.runtime.getSetting('TWITTER_APPROVAL_CHECK_INTERVAL'),\n        ) || 5 * 60 * 1000; // 5 minutes\n\n      this.approvalCheckInterval = APPROVAL_CHECK_INTERVAL;\n\n      if (!discordToken || !approvalChannelId) {\n        throw new Error(\n          'TWITTER_APPROVAL_DISCORD_BOT_TOKEN and TWITTER_APPROVAL_DISCORD_CHANNEL_ID are required for approval workflow',\n        );\n      }\n\n      this.approvalRequired = true;\n      this.discordApprovalChannelId = approvalChannelId;\n\n      // Set up Discord client event handlers\n      this.setupDiscordClient();\n    }\n  }\n\n  private setupDiscordClient() {\n    this.discordClientForApproval = new Client({\n      intents: [\n        GatewayIntentBits.Guilds,\n        GatewayIntentBits.GuildMessages,\n        GatewayIntentBits.MessageContent,\n        GatewayIntentBits.GuildMessageReactions,\n      ],\n      partials: [Partials.Channel, Partials.Message, Partials.Reaction],\n    });\n    this.discordClientForApproval.once(Events.ClientReady, (readyClient) => {\n      this.logger.log(`Discord bot is ready as ${readyClient.user.tag}!`);\n\n      // Generate invite link with required permissions\n      const invite = `https://discord.com/api/oauth2/authorize?client_id=${readyClient.user.id}&permissions=274877991936&scope=bot`;\n      // 274877991936 includes permissions for:\n      // - Send Messages\n      // - Read Messages/View Channels\n      // - Read Message History\n\n      this.logger.log(\n        `Use this link to properly invite the Twitter Post Approval Discord bot: ${invite}`,\n      );\n    });\n    // Login to Discord\n    this.discordClientForApproval.login(\n      this.runtime.getSetting('TWITTER_APPROVAL_DISCORD_BOT_TOKEN'),\n    );\n  }\n\n  async start() {\n    if (!this.client.profile) {\n      await this.client.init();\n    }\n\n    const generateNewTweetLoop = async () => {\n      if (this.backendTaskStatus.generateNewTweet === 0) return;\n      this.backendTaskStatus.generateNewTweet = 1;\n\n      const lastPost = await this.runtime.cacheManager.get<{\n        timestamp: number;\n        id?: string;\n      }>(`twitter/${this.client.profile.username}/lastPost`);\n\n      const lastPostTimestamp = lastPost?.timestamp ?? 0;\n      const minMinutes = this.client.twitterConfig.POST_INTERVAL_MIN;\n      const maxMinutes = this.client.twitterConfig.POST_INTERVAL_MAX;\n      const randomMinutes =\n        Math.floor(Math.random() * (maxMinutes - minMinutes + 1)) + minMinutes;\n      const delay = randomMinutes * 60 * 1000;\n\n      while (Date.now() <= lastPostTimestamp + delay) {\n        // 1 minute\n        await new Promise((resolve) => setTimeout(resolve, 60 * 1000));\n      }\n\n      await this.generateNewTweet();\n      this.backendTaskStatus.generateNewTweet = 2;\n      \n      setTimeout(() => {\n        generateNewTweetLoop().catch( err => {\n          this.logger.error('Error in generateNewTweetLoop:', err);\n        }); // Set up next iteration\n      }, delay);\n\n      this.logger.info(`Next tweet scheduled in ${randomMinutes} minutes`);\n    };\n\n    const processActionsLoop = async () => {\n      const actionInterval = this.client.twitterConfig.ACTION_INTERVAL; // Defaults to 5 minutes\n\n      while (!(this.backendTaskStatus.processTweetActions === 0)) {\n        try {\n          this.backendTaskStatus.processTweetActions = 1;\n          const results = await this.processTweetActions();\n          this.backendTaskStatus.processTweetActions = 2;\n\n          if (results) {\n            this.logger.log(`Processed ${results.length} tweets`);\n            this.logger.log(\n              `Next action processing scheduled in ${actionInterval} minutes`,\n            );\n            // Wait for the full interval before next processing\n            await new Promise(\n              (resolve) => setTimeout(resolve, actionInterval * 60 * 1000), // now in minutes\n            );\n          }\n        } catch (error) {\n          this.logger.error('Error in action processing loop:', error);\n          // Add exponential backoff on error\n          await new Promise((resolve) => setTimeout(resolve, 30000)); // Wait 30s on error\n        }\n      }\n    };\n\n    if (this.client.twitterConfig.POST_IMMEDIATELY) {\n      await this.generateNewTweet();\n    }\n\n    if (this.client.twitterConfig.ENABLE_TWITTER_POST_GENERATION) {\n      generateNewTweetLoop();\n      this.logger.info('Tweet generation loop started');\n    }\n\n    if (this.client.twitterConfig.ENABLE_ACTION_PROCESSING) {\n      processActionsLoop().catch((error) => {\n        this.logger.error('Fatal error in process actions loop:', error);\n      });\n    }\n\n    // Start the pending tweet check loop if enabled\n    if (this.approvalRequired) this.runPendingTweetCheckLoop();\n  }\n\n  private runPendingTweetCheckLoop() {\n    const interval = setInterval(async () => {\n      this.backendTaskStatus.runPendingTweetCheck = 1;\n      await this.handlePendingTweet();\n      this.backendTaskStatus.runPendingTweetCheck = 2;\n    }, this.approvalCheckInterval);\n\n    this.runPendingTweetCheckInterval = interval;\n  }\n\n  createTweetObject(\n    tweetResult: any,\n    client: any,\n    twitterUsername: string,\n  ): Tweet {\n    return {\n      id: tweetResult.rest_id,\n      name: client.profile.screenName,\n      username: client.profile.username,\n      text: tweetResult.legacy.full_text,\n      conversationId: tweetResult.legacy.conversation_id_str,\n      createdAt: tweetResult.legacy.created_at,\n      timestamp: new Date(tweetResult.legacy.created_at).getTime(),\n      userId: client.profile.id,\n      inReplyToStatusId: tweetResult.legacy.in_reply_to_status_id_str,\n      permanentUrl: `https://twitter.com/${twitterUsername}/status/${tweetResult.rest_id}`,\n      hashtags: [],\n      mentions: [],\n      photos: [],\n      thread: [],\n      urls: [],\n      videos: [],\n    } as Tweet;\n  }\n\n  async processAndCacheTweet(\n    runtime: IAgentRuntime,\n    client: ClientBase,\n    tweet: Tweet,\n    roomId: UUID,\n    rawTweetContent: string,\n  ) {\n    // Cache the last post details\n    await runtime.cacheManager.set(\n      `twitter/${client.profile.username}/lastPost`,\n      {\n        id: tweet.id,\n        timestamp: Date.now(),\n      },\n    );\n\n    // Cache the tweet\n    await client.runtimeHelper.cacheTweet(tweet);\n\n    // Log the posted tweet\n    this.logger.log(`Tweet posted:\\n ${tweet.permanentUrl}`);\n\n    // Ensure the room and participant exist\n    await runtime.ensureRoomExists(roomId);\n    await runtime.ensureParticipantInRoom(runtime.agentId, roomId);\n\n    // Create a memory for the tweet\n    await runtime.messageManager.createMemory({\n      id: stringToUuid(tweet.id + '-' + runtime.agentId),\n      userId: runtime.agentId,\n      agentId: runtime.agentId,\n      content: {\n        text: rawTweetContent.trim(),\n        url: tweet.permanentUrl,\n        source: 'twitter',\n      },\n      roomId,\n      embedding: getEmbeddingZeroVector(),\n      createdAt: tweet.timestamp,\n    });\n  }\n\n  async handleNoteTweet(\n    client: ClientBase,\n    content: string,\n    tweetId?: string,\n    mediaData?: MediaData[],\n  ) {\n    try {\n      const noteTweetResult = await client.requestQueue.add(\n        async () =>\n          await client.twitterClient.sendNoteTweet(content, tweetId, mediaData),\n      );\n\n      if (noteTweetResult.errors && noteTweetResult.errors.length > 0) {\n        // Note Tweet failed due to authorization. Falling back to standard Tweet.\n        const truncateContent = truncateToCompleteSentence(\n          content,\n          this.client.twitterConfig.MAX_TWEET_LENGTH,\n        );\n        return await this.sendStandardTweet(client, truncateContent, tweetId);\n      } else {\n        return noteTweetResult.data.notetweet_create.tweet_results.result;\n      }\n    } catch (error) {\n      throw new Error(`Note Tweet failed: ${error}`);\n    }\n  }\n\n  async sendStandardTweet(\n    client: ClientBase,\n    content: string,\n    tweetId?: string,\n    mediaData?: MediaData[],\n  ) {\n    try {\n      const standardTweetResult = await client.requestQueue.add(\n        async () =>\n          await client.twitterClient.sendTweet(content, tweetId, mediaData),\n      );\n      /**\n       * const body = {\n          errors: [\n            {\n              \"message\": \"Authorization: Status is a duplicate. (187)\",\n              \"locations\": [\n                {\n                  \"line\": 18,\n                  \"column\": 3\n                }\n              ],\n              \"path\": [\n                \"create_tweet\"\n              ],\n              \"extensions\": {\n                \"name\": \"AuthorizationError\",\n                \"source\": \"Client\",\n                \"code\": 187,\n                \"kind\": \"Permissions\",\n                \"tracing\": {\n                  \"trace_id\": \"xx\"\n                }\n              },\n              \"code\": 187,\n              \"kind\": \"Permissions\",\n              \"name\": \"AuthorizationError\",\n              \"source\": \"Client\",\n              \"tracing\": {\n                \"trace_id\": \"xx\"\n              }\n            }\n          ],\n          data: {}\n        }\n       */\n      const body = await standardTweetResult.json();\n      if (!body?.data?.create_tweet?.tweet_results?.result) {\n        const errorCode = body?.errors?.[0]?.code;\n        if (errorCode === 187) {\n          this.logger.warn(`Authorization: Status is a duplicate. (187), content: ${content}`)\n        } else {\n          this.logger.error('Error sending tweet; Bad response:', body);\n          // TODO fix 'Authorization: Status is a duplicate. (187)'\n          this.logger.error(\n            `Error sending tweet; contentLen: ${content.length}, content: ${content}`,\n          );\n        }\n        return;\n      }\n      return body.data.create_tweet.tweet_results.result;\n    } catch (error) {\n      // console.log(error)\n      this.logger.error('Error sending standard Tweet:', error);\n      throw error;\n    }\n  }\n\n  async postTweet(\n    runtime: IAgentRuntime,\n    client: ClientBase,\n    tweetTextForPosting: string,\n    roomId: UUID,\n    rawTweetContent: string,\n    twitterUsername: string,\n    mediaData?: MediaData[],\n  ) {\n    try {\n      this.logger.log(`Posting new tweet:\\n`);\n\n      let result;\n\n      if (tweetTextForPosting.length > DEFAULT_MAX_TWEET_LENGTH) {\n        result = await this.handleNoteTweet(\n          client,\n          tweetTextForPosting,\n          undefined,\n          mediaData,\n        );\n      } else {\n        result = await this.sendStandardTweet(\n          client,\n          tweetTextForPosting,\n          undefined,\n          mediaData,\n        );\n      }\n\n      if (result === undefined) {\n        this.logger.error('Error sending tweet; result is undefined');\n        return;\n      }\n\n      twitterPostCount.labels(twitterUsername).inc();\n\n      const tweet = this.createTweetObject(result, client, twitterUsername);\n\n      await this.processAndCacheTweet(\n        runtime,\n        client,\n        tweet,\n        roomId,\n        rawTweetContent,\n      );\n    } catch (error) {\n      this.logger.error('postTweet Error sending tweet:', error);\n    }\n  }\n\n  /**\n   * Generates and posts a new tweet. If isDryRun is true, only logs what would have been posted.\n   */\n  async generateNewTweet() {\n    try {\n      this.logger.log('generatePostTweet start');\n      let postTweet = await this.runtimeTwitterPostHelper.generatePostTweet(this.client.profile.username, this.client.twitterConfig.MAX_TWEET_LENGTH);\n      this.logger.log('generatePostTweet end');\n\n      // check if the tweet content is duplicate\n      // fix 'Authorization: Status is a duplicate. (187)'\n      const lastPost = await this.runtime.cacheManager.get<{\n        timestamp: number;\n        id?: string;\n      }>(`twitter/${this.client.profile.username}/lastPost`);\n      if (lastPost && lastPost.id) {\n        const lastPostContent = await this.runtime.messageManager.getMemoryById(\n          stringToUuid(lastPost.id + '-' + this.runtime.agentId),\n        );\n        if (lastPostContent?.content.text === postTweet.tweetTextForPosting) {\n          this.logger.warn(\n            `The tweet content is the same as the last post, skipping: ${postTweet.tweetTextForPosting}`,\n          );\n          // retry once\n          postTweet = await this.runtimeTwitterPostHelper.generatePostTweet(this.client.profile.username, this.client.twitterConfig.MAX_TWEET_LENGTH);\n        }\n      }\n\n      if (this.isDryRun) {\n        this.logger.info(\n          `Dry run: would have posted tweet: ${postTweet.tweetTextForPosting}`,\n        );\n        return;\n      }\n\n      this.logger.log('postTweet start');\n      if (this.approvalRequired) {\n        // Send for approval instead of posting directly\n        this.logger.log(\n          `Sending Tweet For Approval:\\n ${postTweet.tweetTextForPosting}`,\n        );\n        await this.sendForApproval(\n          postTweet.tweetTextForPosting,\n          postTweet.roomId,\n          postTweet.rawTweetContent,\n        );\n        this.logger.log('Tweet sent for approval');\n      } else {\n        this.logger.log(`Posting new tweet:\\n ${postTweet.tweetTextForPosting}`);\n        this.postTweet(\n          this.runtime,\n          this.client,\n          postTweet.tweetTextForPosting,\n          postTweet.roomId,\n          postTweet.rawTweetContent,\n          this.twitterUsername,\n          postTweet.mediaData,\n        ).catch((error) => {\n          this.logger.error('Error posting tweet:', error);\n        });\n      }\n      this.logger.log('postTweet end');\n    } catch (error) {\n      this.logger.error('Error generateNewTweet:', error);\n    }\n  }\n\n  private async generateTweetContent(\n    tweetState: any,\n    options?: {\n      template?: TemplateType;\n      context?: string;\n    },\n  ): Promise<string> {\n    const context = composeContext({\n      state: tweetState,\n      template:\n        options?.template ||\n        this.runtime.character.templates?.twitterPostTemplate ||\n        twitterPostTemplate,\n    });\n\n    const response = await generateText({\n      runtime: this.runtime,\n      context: options?.context || context,\n      modelClass: ModelClass.SMALL,\n    });\n\n    this.logger.log('generate tweet content response:\\n' + response);\n\n    // First clean up any markdown and newlines\n    const cleanedResponse = cleanJsonResponse(response);\n\n    // Try to parse as JSON first\n    const jsonResponse = parseJSONObjectFromText(cleanedResponse);\n    if (jsonResponse.text) {\n      const truncateContent = truncateToCompleteSentence(\n        jsonResponse.text,\n        this.client.twitterConfig.MAX_TWEET_LENGTH,\n      );\n      return truncateContent;\n    }\n    if (typeof jsonResponse === 'object') {\n      const possibleContent =\n        jsonResponse.content || jsonResponse.message || jsonResponse.response;\n      if (possibleContent) {\n        const truncateContent = truncateToCompleteSentence(\n          possibleContent,\n          this.client.twitterConfig.MAX_TWEET_LENGTH,\n        );\n        return truncateContent;\n      }\n    }\n\n    let truncateContent = null;\n    // Try extracting text attribute\n    const parsingText = extractAttributes(cleanedResponse, ['text']).text;\n    if (parsingText) {\n      truncateContent = truncateToCompleteSentence(\n        parsingText,\n        this.client.twitterConfig.MAX_TWEET_LENGTH,\n      );\n    }\n\n    if (!truncateContent) {\n      // If not JSON or no valid content found, clean the raw text\n      truncateContent = truncateToCompleteSentence(\n        cleanedResponse,\n        this.client.twitterConfig.MAX_TWEET_LENGTH,\n      );\n    }\n\n    return truncateContent;\n  }\n\n  /**\n   * Processes tweet actions (likes, retweets, quotes, replies). If isDryRun is true,\n   * only simulates and logs actions without making API calls.\n   */\n  private async processTweetActions() {\n    if (this.isProcessing) {\n      this.logger.log('Already processing tweet actions, skipping');\n      return null;\n    }\n\n    try {\n      this.isProcessing = true;\n      this.lastProcessTime = Date.now();\n\n      this.logger.log('Processing tweet actions');\n\n      await this.runtime.ensureUserExists(\n        this.runtime.agentId,\n        this.twitterUsername,\n        this.runtime.character.name,\n        'twitter',\n      );\n\n      const timelines = await this.client.fetchTimelineForActions(\n        MAX_TIMELINES_TO_FETCH,\n      );\n      const maxActionsProcessing =\n        this.client.twitterConfig.MAX_ACTIONS_PROCESSING;\n      const processedTimelines = [];\n\n      for (const tweet of timelines) {\n        try {\n          // Skip if we've already processed this tweet\n          const memory = await this.runtime.messageManager.getMemoryById(\n            stringToUuid(tweet.id + '-' + this.runtime.agentId),\n          );\n          if (memory) {\n            this.logger.log(`Already processed tweet ID: ${tweet.id}`);\n            continue;\n          }\n\n          const roomId = stringToUuid(\n            tweet.conversationId + '-' + this.runtime.agentId,\n          );\n\n          const tweetState = await this.runtime.composeState(\n            {\n              userId: this.runtime.agentId,\n              roomId,\n              agentId: this.runtime.agentId,\n              content: { text: '', action: '' },\n            },\n            {\n              twitterUserName: this.twitterUsername,\n              currentTweet: `ID: ${tweet.id}\\nFrom: ${tweet.name} (@${tweet.username})\\nText: ${tweet.text}`,\n            },\n          );\n\n          const actionContext = composeContext({\n            state: tweetState,\n            template:\n              this.runtime.character.templates?.twitterActionTemplate ||\n              twitterActionTemplate,\n          });\n\n          const actionResponse = await generateTweetActions({\n            runtime: this.runtime,\n            context: actionContext,\n            modelClass: ModelClass.SMALL,\n          });\n\n          if (!actionResponse) {\n            this.logger.log(`No valid actions generated for tweet ${tweet.id}`);\n            continue;\n          }\n          processedTimelines.push({\n            tweet: tweet,\n            actionResponse: actionResponse,\n            tweetState: tweetState,\n            roomId: roomId,\n          });\n        } catch (error) {\n          this.logger.error(`Error processing tweet ${tweet.id}:`, error);\n          continue;\n        }\n      }\n\n      const sortProcessedTimeline = (arr: typeof processedTimelines) => {\n        return arr.sort((a, b) => {\n          // Count the number of true values in the actionResponse object\n          const countTrue = (obj: typeof a.actionResponse) =>\n            Object.values(obj).filter(Boolean).length;\n\n          const countA = countTrue(a.actionResponse);\n          const countB = countTrue(b.actionResponse);\n\n          // Primary sort by number of true values\n          if (countA !== countB) {\n            return countB - countA;\n          }\n\n          // Secondary sort by the \"like\" property\n          if (a.actionResponse.like !== b.actionResponse.like) {\n            return a.actionResponse.like ? -1 : 1;\n          }\n\n          // Tertiary sort keeps the remaining objects with equal weight\n          return 0;\n        });\n      };\n      // Sort the timeline based on the action decision score,\n      // then slice the results according to the environment variable to limit the number of actions per cycle.\n      const sortedTimelines = sortProcessedTimeline(processedTimelines).slice(\n        0,\n        maxActionsProcessing,\n      );\n\n      return this.processTimelineActions(sortedTimelines); // Return results array to indicate completion\n    } catch (error) {\n      this.logger.error('Error in processTweetActions:', error);\n      throw error;\n    } finally {\n      this.isProcessing = false;\n    }\n  }\n\n  /**\n   * Processes a list of timelines by executing the corresponding tweet actions.\n   * Each timeline includes the tweet, action response, tweet state, and room context.\n   * Results are returned for tracking completed actions.\n   *\n   * @param timelines - Array of objects containing tweet details, action responses, and state information.\n   * @returns A promise that resolves to an array of results with details of executed actions.\n   */\n  private async processTimelineActions(\n    timelines: {\n      tweet: Tweet;\n      actionResponse: ActionResponse;\n      tweetState: State;\n      roomId: UUID;\n    }[],\n  ): Promise<\n    {\n      tweetId: string;\n      actionResponse: ActionResponse;\n      executedActions: string[];\n    }[]\n  > {\n    const results = [];\n    for (const timeline of timelines) {\n      const { actionResponse, tweetState, roomId, tweet } = timeline;\n      try {\n        const executedActions: string[] = [];\n        // Execute actions\n        if (actionResponse.like) {\n          if (this.isDryRun) {\n            this.logger.info(`Dry run: would have liked tweet ${tweet.id}`);\n            executedActions.push('like (dry run)');\n          } else {\n            try {\n              await this.client.twitterClient.likeTweet(tweet.id);\n              executedActions.push('like');\n              this.logger.log(`Liked tweet ${tweet.id}`);\n            } catch (error) {\n              this.logger.error(`Error liking tweet ${tweet.id}:`, error);\n            }\n          }\n        }\n\n        if (actionResponse.retweet) {\n          if (this.isDryRun) {\n            this.logger.info(`Dry run: would have retweeted tweet ${tweet.id}`);\n            executedActions.push('retweet (dry run)');\n          } else {\n            try {\n              await this.client.twitterClient.retweet(tweet.id);\n              executedActions.push('retweet');\n              this.logger.log(`Retweeted tweet ${tweet.id}`);\n            } catch (error) {\n              this.logger.error(`Error retweeting tweet ${tweet.id}:`, error);\n            }\n          }\n        }\n\n        if (actionResponse.quote) {\n          try {\n            // Build conversation thread for context\n            const thread = await buildConversationThread(tweet, this.client);\n            const formattedConversation = thread\n              .map(\n                (t) =>\n                  `@${t.username} (${new Date(\n                    t.timestamp * 1000,\n                  ).toLocaleString()}): ${t.text}`,\n              )\n              .join('\\n\\n');\n\n            // Generate image descriptions if present\n            const imageDescriptions = [];\n            if (tweet.photos?.length > 0) {\n              this.logger.log('Processing images in tweet for context');\n              for (const photo of tweet.photos) {\n                const description = await this.runtime\n                  .getService<IImageDescriptionService>(\n                    ServiceType.IMAGE_DESCRIPTION,\n                  )\n                  .describeImage(photo.url);\n                imageDescriptions.push(description);\n              }\n            }\n\n            // Handle quoted tweet if present\n            let quotedContent = '';\n            if (tweet.quotedStatusId) {\n              try {\n                const quotedTweet = await this.client.twitterClient.getTweet(\n                  tweet.quotedStatusId,\n                );\n                if (quotedTweet) {\n                  quotedContent = `\\nQuoted Tweet from @${quotedTweet.username}:\\n${quotedTweet.text}`;\n                }\n              } catch (error) {\n                this.logger.error('Error fetching quoted tweet:', error);\n              }\n            }\n\n            // Compose rich state with all context\n            const enrichedState = await this.runtime.composeState(\n              {\n                userId: this.runtime.agentId,\n                roomId: stringToUuid(\n                  tweet.conversationId + '-' + this.runtime.agentId,\n                ),\n                agentId: this.runtime.agentId,\n                content: {\n                  text: tweet.text,\n                  action: 'QUOTE',\n                },\n              },\n              {\n                twitterUserName: this.twitterUsername,\n                currentPost: `From @${tweet.username}: ${tweet.text}`,\n                formattedConversation,\n                imageContext:\n                  imageDescriptions.length > 0\n                    ? `\\nImages in Tweet:\\n${imageDescriptions\n                        .map((desc, i) => `Image ${i + 1}: ${desc}`)\n                        .join('\\n')}`\n                    : '',\n                quotedContent,\n              },\n            );\n\n            const quoteContent = await this.generateTweetContent(\n              enrichedState,\n              {\n                template:\n                  this.runtime.character.templates\n                    ?.twitterMessageHandlerTemplate ||\n                  twitterMessageHandlerTemplate,\n              },\n            );\n\n            if (!quoteContent) {\n              this.logger.error('Failed to generate valid quote tweet content');\n              return;\n            }\n\n            this.logger.log('Generated quote tweet content:', quoteContent);\n            // Check for dry run mode\n            if (this.isDryRun) {\n              this.logger.info(\n                `Dry run: A quote tweet for tweet ID ${tweet.id} would have been posted with the following content: \"${quoteContent}\".`,\n              );\n              executedActions.push('quote (dry run)');\n            } else {\n              // Send the tweet through request queue\n              const result = await this.client.requestQueue.add(\n                async () =>\n                  await this.client.twitterClient.sendQuoteTweet(\n                    quoteContent,\n                    tweet.id,\n                  ),\n              );\n\n              const body = await result.json();\n\n              if (body?.data?.create_tweet?.tweet_results?.result) {\n                this.logger.log('Successfully posted quote tweet');\n                executedActions.push('quote');\n\n                // Cache generation context for debugging\n                await this.runtime.cacheManager.set(\n                  `twitter/quote_generation_${tweet.id}.txt`,\n                  `Context:\\n${enrichedState}\\n\\nGenerated Quote:\\n${quoteContent}`,\n                );\n              } else {\n                this.logger.error('Quote tweet creation failed:', body);\n              }\n            }\n          } catch (error) {\n            this.logger.error('Error in quote tweet generation:', error);\n          }\n        }\n\n        if (actionResponse.reply) {\n          try {\n            await this.handleTextOnlyReply(tweet, tweetState, executedActions);\n          } catch (error) {\n            this.logger.error(`Error replying to tweet ${tweet.id}:`, error);\n          }\n        }\n\n        // Add these checks before creating memory\n        await this.runtime.ensureRoomExists(roomId);\n        await this.runtime.ensureUserExists(\n          stringToUuid(tweet.userId),\n          tweet.username,\n          tweet.name,\n          'twitter',\n        );\n        await this.runtime.ensureParticipantInRoom(\n          this.runtime.agentId,\n          roomId,\n        );\n\n        if (!this.isDryRun) {\n          // Then create the memory\n          await this.runtime.messageManager.createMemory({\n            id: stringToUuid(tweet.id + '-' + this.runtime.agentId),\n            userId: stringToUuid(tweet.userId),\n            content: {\n              text: tweet.text,\n              url: tweet.permanentUrl,\n              source: 'twitter',\n              action: executedActions.join(','),\n            },\n            agentId: this.runtime.agentId,\n            roomId,\n            embedding: getEmbeddingZeroVector(),\n            createdAt: tweet.timestamp * 1000,\n          });\n        }\n\n        results.push({\n          tweetId: tweet.id,\n          actionResponse: actionResponse,\n          executedActions,\n        });\n      } catch (error) {\n        this.logger.error(`Error processing tweet ${tweet.id}:`, error);\n        continue;\n      }\n    }\n\n    return results;\n  }\n\n  /**\n   * Handles text-only replies to tweets. If isDryRun is true, only logs what would\n   * have been replied without making API calls.\n   */\n  private async handleTextOnlyReply(\n    tweet: Tweet,\n    tweetState: any,\n    executedActions: string[],\n  ) {\n    try {\n      // Build conversation thread for context\n      const thread = await buildConversationThread(tweet, this.client);\n      const formattedConversation = thread\n        .map(\n          (t) =>\n            `@${t.username} (${new Date(\n              t.timestamp * 1000,\n            ).toLocaleString()}): ${t.text}`,\n        )\n        .join('\\n\\n');\n\n      // Generate image descriptions if present\n      const imageDescriptions = [];\n      if (tweet.photos?.length > 0) {\n        this.logger.log('Processing images in tweet for context');\n        for (const photo of tweet.photos) {\n          const description = await this.runtime\n            .getService<IImageDescriptionService>(ServiceType.IMAGE_DESCRIPTION)\n            .describeImage(photo.url);\n          imageDescriptions.push(description);\n        }\n      }\n\n      // Handle quoted tweet if present\n      let quotedContent = '';\n      if (tweet.quotedStatusId) {\n        try {\n          const quotedTweet = await this.client.twitterClient.getTweet(\n            tweet.quotedStatusId,\n          );\n          if (quotedTweet) {\n            quotedContent = `\\nQuoted Tweet from @${quotedTweet.username}:\\n${quotedTweet.text}`;\n          }\n        } catch (error) {\n          this.logger.error('Error fetching quoted tweet:', error);\n        }\n      }\n\n      // Compose rich state with all context\n      const enrichedState = await this.runtime.composeState(\n        {\n          userId: this.runtime.agentId,\n          roomId: stringToUuid(\n            tweet.conversationId + '-' + this.runtime.agentId,\n          ),\n          agentId: this.runtime.agentId,\n          content: { text: tweet.text, action: '' },\n        },\n        {\n          twitterUserName: this.twitterUsername,\n          currentPost: `From @${tweet.username}: ${tweet.text}`,\n          formattedConversation,\n          imageContext:\n            imageDescriptions.length > 0\n              ? `\\nImages in Tweet:\\n${imageDescriptions\n                  .map((desc, i) => `Image ${i + 1}: ${desc}`)\n                  .join('\\n')}`\n              : '',\n          quotedContent,\n        },\n      );\n\n      // Generate and clean the reply content\n      const replyText = await this.generateTweetContent(enrichedState, {\n        template:\n          this.runtime.character.templates?.twitterMessageHandlerTemplate ||\n          twitterMessageHandlerTemplate,\n      });\n\n      if (!replyText) {\n        this.logger.error('Failed to generate valid reply content');\n        return;\n      }\n\n      if (this.isDryRun) {\n        this.logger.info(\n          `Dry run: reply to tweet ${tweet.id} would have been: ${replyText}`,\n        );\n        executedActions.push('reply (dry run)');\n        return;\n      }\n\n      this.logger.debug('Final reply text to be sent:', replyText);\n\n      let result;\n\n      if (replyText.length > DEFAULT_MAX_TWEET_LENGTH) {\n        result = await this.handleNoteTweet(this.client, replyText, tweet.id);\n      } else {\n        result = await this.sendStandardTweet(this.client, replyText, tweet.id);\n      }\n\n      if (result) {\n        this.logger.log('Successfully posted reply tweet');\n        executedActions.push('reply');\n\n        // Cache generation context for debugging\n        await this.runtime.cacheManager.set(\n          `twitter/reply_generation_${tweet.id}.txt`,\n          `Context:\\n${enrichedState}\\n\\nGenerated Reply:\\n${replyText}`,\n        );\n      } else {\n        this.logger.error('Tweet reply creation failed');\n      }\n    } catch (error) {\n      this.logger.error('Error in handleTextOnlyReply:', error);\n    }\n  }\n\n  // if false, should stop again\n  async stop(): Promise<boolean> {\n    // TODO loop check\n    if (this.backendTaskStatus.generateNewTweet === 2) {\n      this.backendTaskStatus.generateNewTweet = 0;\n      this.logger.info(`${this.twitterUsername} task generateNewTweet stopped`);\n    } else if (this.backendTaskStatus.generateNewTweet === 0) {\n      // stopped\n    } else {\n      return false;\n    }\n\n    if (this.backendTaskStatus.processTweetActions === 2) {\n      this.backendTaskStatus.processTweetActions = 0;\n      this.logger.info(\n        `${this.twitterUsername} task processTweetActions stopped`,\n      );\n    } else if (this.backendTaskStatus.processTweetActions === 0) {\n      // stopped\n    } else {\n      return false;\n    }\n\n    if (this.runPendingTweetCheckInterval) {\n      clearInterval(this.runPendingTweetCheckInterval);\n      this.runPendingTweetCheckInterval = null;\n      this.backendTaskStatus.runPendingTweetCheck = 0;\n      this.logger.info(\n        `${this.twitterUsername} task runPendingTweetCheckInterval stopped`,\n      );\n    }\n\n    return true;\n  }\n\n  private async sendForApproval(\n    tweetTextForPosting: string,\n    roomId: UUID,\n    rawTweetContent: string,\n  ): Promise<string | null> {\n    try {\n      const embed = {\n        title: 'New Tweet Pending Approval',\n        description: tweetTextForPosting,\n        fields: [\n          {\n            name: 'Character',\n            value: this.client.profile.username,\n            inline: true,\n          },\n          {\n            name: 'Length',\n            value: tweetTextForPosting.length.toString(),\n            inline: true,\n          },\n        ],\n        footer: {\n          text: \"Reply with '' to post or '' to discard, This will automatically expire and remove after 24 hours if no response received\",\n        },\n        timestamp: new Date().toISOString(),\n      };\n\n      const channel = await this.discordClientForApproval.channels.fetch(\n        this.discordApprovalChannelId,\n      );\n\n      if (!channel || !(channel instanceof TextChannel)) {\n        throw new Error('Invalid approval channel');\n      }\n\n      const message = await channel.send({ embeds: [embed] });\n\n      // Store the pending tweet\n      const pendingTweetsKey = `twitter/${this.client.profile.username}/pendingTweet`;\n      const currentPendingTweets =\n        (await this.runtime.cacheManager.get<PendingTweet[]>(\n          pendingTweetsKey,\n        )) || [];\n      // Add new pending tweet\n      currentPendingTweets.push({\n        tweetTextForPosting,\n        roomId,\n        rawTweetContent,\n        discordMessageId: message.id,\n        channelId: this.discordApprovalChannelId,\n        timestamp: Date.now(),\n      });\n\n      // Store updated array\n      await this.runtime.cacheManager.set(\n        pendingTweetsKey,\n        currentPendingTweets,\n      );\n\n      return message.id;\n    } catch (error) {\n      this.logger.error('Error Sending Twitter Post Approval Request:', error);\n      return null;\n    }\n  }\n\n  private async checkApprovalStatus(\n    discordMessageId: string,\n  ): Promise<PendingTweetApprovalStatus> {\n    try {\n      // Fetch message and its replies from Discord\n      const channel = await this.discordClientForApproval.channels.fetch(\n        this.discordApprovalChannelId,\n      );\n\n      this.logger.log(`channel ${JSON.stringify(channel)}`);\n\n      if (!(channel instanceof TextChannel)) {\n        this.logger.error('Invalid approval channel');\n        return 'PENDING';\n      }\n\n      // Fetch the original message and its replies\n      const message = await channel.messages.fetch(discordMessageId);\n\n      // Look for thumbs up reaction ('')\n      const thumbsUpReaction = message.reactions.cache.find(\n        (reaction) => reaction.emoji.name === '',\n      );\n\n      // Look for reject reaction ('')\n      const rejectReaction = message.reactions.cache.find(\n        (reaction) => reaction.emoji.name === '',\n      );\n\n      // Check if the reaction exists and has reactions\n      if (rejectReaction) {\n        const count = rejectReaction.count;\n        if (count > 0) {\n          return 'REJECTED';\n        }\n      }\n\n      // Check if the reaction exists and has reactions\n      if (thumbsUpReaction) {\n        // You might want to check for specific users who can approve\n        // For now, we'll return true if anyone used thumbs up\n        const count = thumbsUpReaction.count;\n        if (count > 0) {\n          return 'APPROVED';\n        }\n      }\n\n      return 'PENDING';\n    } catch (error) {\n      this.logger.error('Error checking approval status:', error);\n      return 'PENDING';\n    }\n  }\n\n  private async cleanupPendingTweet(discordMessageId: string) {\n    const pendingTweetsKey = `twitter/${this.client.profile.username}/pendingTweet`;\n    const currentPendingTweets =\n      (await this.runtime.cacheManager.get<PendingTweet[]>(pendingTweetsKey)) ||\n      [];\n\n    // Remove the specific tweet\n    const updatedPendingTweets = currentPendingTweets.filter(\n      (tweet) => tweet.discordMessageId !== discordMessageId,\n    );\n\n    if (updatedPendingTweets.length === 0) {\n      await this.runtime.cacheManager.delete(pendingTweetsKey);\n    } else {\n      await this.runtime.cacheManager.set(\n        pendingTweetsKey,\n        updatedPendingTweets,\n      );\n    }\n  }\n\n  private async handlePendingTweet() {\n    this.logger.log('Checking Pending Tweets...');\n    const pendingTweetsKey = `twitter/${this.client.profile.username}/pendingTweet`;\n    const pendingTweets =\n      (await this.runtime.cacheManager.get<PendingTweet[]>(pendingTweetsKey)) ||\n      [];\n\n    for (const pendingTweet of pendingTweets) {\n      // Check if tweet is older than 24 hours\n      const isExpired =\n        Date.now() - pendingTweet.timestamp > 24 * 60 * 60 * 1000;\n\n      if (isExpired) {\n        this.logger.log('Pending tweet expired, cleaning up');\n\n        // Notify on Discord about expiration\n        try {\n          const channel = await this.discordClientForApproval.channels.fetch(\n            pendingTweet.channelId,\n          );\n          if (channel instanceof TextChannel) {\n            const originalMessage = await channel.messages.fetch(\n              pendingTweet.discordMessageId,\n            );\n            await originalMessage.reply(\n              'This tweet approval request has expired (24h timeout).',\n            );\n          }\n        } catch (error) {\n          this.logger.error('Error sending expiration notification:', error);\n        }\n\n        await this.cleanupPendingTweet(pendingTweet.discordMessageId);\n        return;\n      }\n\n      // Check approval status\n      this.logger.log('Checking approval status...');\n      const approvalStatus: PendingTweetApprovalStatus =\n        await this.checkApprovalStatus(pendingTweet.discordMessageId);\n\n      if (approvalStatus === 'APPROVED') {\n        this.logger.log('Tweet Approved, Posting');\n        await this.postTweet(\n          this.runtime,\n          this.client,\n          pendingTweet.tweetTextForPosting,\n          pendingTweet.roomId,\n          pendingTweet.rawTweetContent,\n          this.twitterUsername,\n        );\n\n        // Notify on Discord about posting\n        try {\n          const channel = await this.discordClientForApproval.channels.fetch(\n            pendingTweet.channelId,\n          );\n          if (channel instanceof TextChannel) {\n            const originalMessage = await channel.messages.fetch(\n              pendingTweet.discordMessageId,\n            );\n            await originalMessage.reply(\n              'Tweet has been posted successfully! ',\n            );\n          }\n        } catch (error) {\n          this.logger.error('Error sending post notification:', error);\n        }\n\n        await this.cleanupPendingTweet(pendingTweet.discordMessageId);\n      } else if (approvalStatus === 'REJECTED') {\n        this.logger.log('Tweet Rejected, Cleaning Up');\n        await this.cleanupPendingTweet(pendingTweet.discordMessageId);\n        // Notify about Rejection of Tweet\n        try {\n          const channel = await this.discordClientForApproval.channels.fetch(\n            pendingTweet.channelId,\n          );\n          if (channel instanceof TextChannel) {\n            const originalMessage = await channel.messages.fetch(\n              pendingTweet.discordMessageId,\n            );\n            await originalMessage.reply('Tweet has been rejected! ');\n          }\n        } catch (error) {\n          this.logger.error('Error sending rejection notification:', error);\n        }\n      }\n    }\n  }\n}\n\ninterface TokenTweet {\n  id: number;\n  token_address: string;\n  symbol: string;\n  network: string;\n  text: string;\n  favorite_count: number;\n  quote_count: number;\n  reply_count: number;\n  retweet_count: number;\n}\n\nasync function getTrendingTokens(birdeypeApiKey: string): Promise<\n  {\n    address: string;\n    symbol: string;\n    name: string;\n  }[]\n> {\n  const url =\n    'https://public-api.birdeye.so/defi/token_trending?sort_by=volume24hUSD&sort_type=desc&offset=0&limit=20';\n  try {\n    const response = await fetch(url, {\n      method: 'GET',\n      headers: {\n        'X-API-KEY': birdeypeApiKey,\n        accept: 'application/json',\n        'x-chain': 'solana',\n      },\n    });\n    const result = await response.json();\n    return result?.data.tokens;\n  } catch (error) {\n    Logger.error(`Error fetching trending tokens:, error`);\n    return null;\n  }\n}\n\nasync function fetchPumpNews(\n  apikey: string,\n  token: string,\n): Promise<TokenTweet[]> {\n  const url = `https://api.pump.news/tweets/list?tokenAddress=${token}&pageSize=20`;\n  try {\n    const response = await fetch(url, {\n      method: 'GET',\n      headers: {\n        accept: '*/*',\n        apikey: apikey,\n      },\n    });\n    const result = await response.json();\n    return result?.data.tweets;\n  } catch (e) {\n    Logger.error(`Error fetching pump news: ${e}`);\n    return null;\n  }\n}\n","// using prometheus client\nimport client from 'prom-client';\n\n// export const register = new client.Registry();\n\n// client.collectDefaultMetrics({\n//   prefix: 'client_twitter_',\n//   register,\n// });\n\nconst prefix = 'client_twitter_';\n\nexport const twitterAccountStatus = new client.Gauge({\n  name: `${prefix}twitter_account_status`,\n  help: 'twitter account running status, 0 stopped, 1 running, 2 stopping',\n  // registers: [register],\n  labelNames: ['twitterName', 'ip'],\n});\n\n// using the post interval and post count to check if there has any missing post\nexport const twitterPostInterval = new client.Gauge({\n  name: `${prefix}twitter_post_interval`,\n  help: 'max post interval in minutes',\n  // registers: [register],\n  labelNames: ['twitterName'],\n});\n\nexport const twitterPostCount = new client.Counter({\n  name: `${prefix}twitter_post_count`,\n  help: 'post count',\n  // registers: [register],\n  labelNames: ['twitterName'],\n});\n","import { SearchMode } from 'agent-twitter-client';\nimport { composeContext } from '@elizaos/core';\nimport { generateMessageResponse, generateText } from '@elizaos/core';\nimport { messageCompletionFooter } from '@elizaos/core';\nimport {\n  type Content,\n  type HandlerCallback,\n  type IAgentRuntime,\n  type IImageDescriptionService,\n  ModelClass,\n  ServiceType,\n  type State,\n} from '@elizaos/core';\nimport { stringToUuid } from '@elizaos/core';\nimport type { ClientBase } from './base';\nimport { buildConversationThread, sendTweet, wait } from './utils.js';\nimport pino from 'pino';\n\nconst twitterSearchTemplate =\n  `{{timeline}}\n\n{{providers}}\n\nRecent interactions between {{agentName}} and other users:\n{{recentPostInteractions}}\n\nAbout {{agentName}} (@{{twitterUserName}}):\n{{bio}}\n{{lore}}\n{{topics}}\n\n{{postDirections}}\n\n{{recentPosts}}\n\n# Task: Respond to the following post in the style and perspective of {{agentName}} (aka @{{twitterUserName}}). Write a {{adjective}} response for {{agentName}} to say directly in response to the post. don't generalize.\n{{currentPost}}\n\nIMPORTANT: Your response CANNOT be longer than 20 words.\nAim for 1-2 short sentences maximum. Be concise and direct.\n\nYour response should not contain any questions. Brief, concise statements only. No emojis. Use \\\\n\\\\n (double spaces) between statements.\n\n` + messageCompletionFooter;\n\nexport class TwitterSearchClient {\n  client: ClientBase;\n  runtime: IAgentRuntime;\n  twitterUsername: string;\n  private respondedTweets: Set<string> = new Set();\n\n  private backendTaskStatus: {\n    // 0 stopped, 1 running, 2 completed\n    engageWithSearchTerms: number;\n  } = {\n    engageWithSearchTerms: 2,\n  };\n\n  private logger: pino.Logger<string, boolean>;\n\n  constructor(client: ClientBase, runtime: IAgentRuntime) {\n    this.client = client;\n    this.runtime = runtime;\n    this.twitterUsername = this.client.twitterConfig.TWITTER_USERNAME;\n    this.logger = client.logger;\n  }\n\n  async stop() {\n    if (this.backendTaskStatus.engageWithSearchTerms === 2) {\n      this.backendTaskStatus.engageWithSearchTerms = 0;\n      const twitterUsername = this.client.twitterConfig.TWITTER_USERNAME;\n      this.logger.info(`${twitterUsername} task engageWithSearchTerms stopped`);\n    } else if (this.backendTaskStatus.engageWithSearchTerms === 0) {\n      // stopped\n    } else {\n      return false;\n    }\n\n    return true;\n  }\n\n  async start() {\n    this.engageWithSearchTermsLoop();\n  }\n\n  private engageWithSearchTermsLoop() {\n    if (this.backendTaskStatus.engageWithSearchTerms === 0) return;\n    this.backendTaskStatus.engageWithSearchTerms = 1;\n\n    this.engageWithSearchTerms().then();\n    const randomMinutes = Math.floor(Math.random() * (120 - 60 + 1)) + 60;\n    this.logger.log(\n      `Next twitter search scheduled in ${randomMinutes} minutes`,\n    );\n    this.backendTaskStatus.engageWithSearchTerms = 2;\n\n    setTimeout(\n      () => this.engageWithSearchTermsLoop(),\n      randomMinutes * 60 * 1000,\n    );\n  }\n\n  private async engageWithSearchTerms() {\n    this.logger.log('Engaging with search terms');\n    try {\n      const searchTerm = [...this.runtime.character.topics][\n        Math.floor(Math.random() * this.runtime.character.topics.length)\n      ];\n\n      this.logger.log('Fetching search tweets');\n      // TODO: we wait 5 seconds here to avoid getting rate limited on startup, but we should queue\n      await new Promise((resolve) => setTimeout(resolve, 5000));\n      const recentTweets = await this.client.fetchSearchTweets(\n        searchTerm,\n        20,\n        SearchMode.Top,\n      );\n      this.logger.log('Search tweets fetched');\n\n      const homeTimeline = await this.client.fetchHomeTimeline(50);\n\n      await this.client.cacheTimeline(homeTimeline);\n\n      const formattedHomeTimeline =\n        `# ${this.runtime.character.name}'s Home Timeline\\n\\n` +\n        homeTimeline\n          .map((tweet) => {\n            return `ID: ${tweet.id}\\nFrom: ${tweet.name} (@${tweet.username})${tweet.inReplyToStatusId ? ` In reply to: ${tweet.inReplyToStatusId}` : ''}\\nText: ${tweet.text}\\n---\\n`;\n          })\n          .join('\\n');\n\n      // randomly slice .tweets down to 20\n      const slicedTweets = recentTweets.tweets\n        .sort(() => Math.random() - 0.5)\n        .slice(0, 20);\n\n      if (slicedTweets.length === 0) {\n        this.logger.log(\n          'No valid tweets found for the search term',\n          searchTerm,\n        );\n        return;\n      }\n\n      const prompt = `\n  Here are some tweets related to the search term \"${searchTerm}\":\n\n  ${[...slicedTweets, ...homeTimeline]\n    .filter((tweet) => {\n      // ignore tweets where any of the thread tweets contain a tweet by the bot\n      const thread = tweet.thread;\n      const botTweet = thread.find((t) => t.username === this.twitterUsername);\n      return !botTweet;\n    })\n    .map(\n      (tweet) => `\n    ID: ${tweet.id}${tweet.inReplyToStatusId ? ` In reply to: ${tweet.inReplyToStatusId}` : ''}\n    From: ${tweet.name} (@${tweet.username})\n    Text: ${tweet.text}\n  `,\n    )\n    .join('\\n')}\n\n  Which tweet is the most interesting and relevant for Ruby to reply to? Please provide only the ID of the tweet in your response.\n  Notes:\n    - Respond to English tweets only\n    - Respond to tweets that don't have a lot of hashtags, links, URLs or images\n    - Respond to tweets that are not retweets\n    - Respond to tweets where there is an easy exchange of ideas to have with the user\n    - ONLY respond with the ID of the tweet`;\n\n      const mostInterestingTweetResponse = await generateText({\n        runtime: this.runtime,\n        context: prompt,\n        modelClass: ModelClass.SMALL,\n      });\n\n      const tweetId = mostInterestingTweetResponse.trim();\n      const selectedTweet = slicedTweets.find(\n        (tweet) =>\n          tweet.id.toString().includes(tweetId) ||\n          tweetId.includes(tweet.id.toString()),\n      );\n\n      if (!selectedTweet) {\n        this.logger.warn('No matching tweet found for the selected ID');\n        this.logger.log('Selected tweet ID:', tweetId);\n        return;\n      }\n\n      this.logger.log('Selected tweet to reply to:', selectedTweet?.text);\n\n      if (selectedTweet.username === this.twitterUsername) {\n        this.logger.log('Skipping tweet from bot itself');\n        return;\n      }\n\n      const conversationId = selectedTweet.conversationId;\n      const roomId = stringToUuid(conversationId + '-' + this.runtime.agentId);\n\n      const userIdUUID = stringToUuid(selectedTweet.userId as string);\n\n      await this.runtime.ensureConnection(\n        userIdUUID,\n        roomId,\n        selectedTweet.username,\n        selectedTweet.name,\n        'twitter',\n      );\n\n      // crawl additional conversation tweets, if there are any\n      await buildConversationThread(selectedTweet, this.client);\n\n      const message = {\n        id: stringToUuid(selectedTweet.id + '-' + this.runtime.agentId),\n        agentId: this.runtime.agentId,\n        content: {\n          text: selectedTweet.text,\n          url: selectedTweet.permanentUrl,\n          inReplyTo: selectedTweet.inReplyToStatusId\n            ? stringToUuid(\n                selectedTweet.inReplyToStatusId + '-' + this.runtime.agentId,\n              )\n            : undefined,\n        },\n        userId: userIdUUID,\n        roomId,\n        // Timestamps are in seconds, but we need them in milliseconds\n        createdAt: selectedTweet.timestamp * 1000,\n      };\n\n      if (!message.content.text) {\n        this.logger.warn('Returning: No response text found');\n        return;\n      }\n\n      // Fetch replies and retweets\n      const replies = selectedTweet.thread;\n      const replyContext = replies\n        .filter((reply) => reply.username !== this.twitterUsername)\n        .map((reply) => `@${reply.username}: ${reply.text}`)\n        .join('\\n');\n\n      let tweetBackground = '';\n      if (selectedTweet.isRetweet) {\n        const originalTweet = await this.client.requestQueue.add(() =>\n          this.client.twitterClient.getTweet(selectedTweet.id),\n        );\n        tweetBackground = `Retweeting @${originalTweet.username}: ${originalTweet.text}`;\n      }\n\n      // Generate image descriptions using GPT-4 vision API\n      const imageDescriptions = [];\n      for (const photo of selectedTweet.photos) {\n        const description = await this.runtime\n          .getService<IImageDescriptionService>(ServiceType.IMAGE_DESCRIPTION)\n          .describeImage(photo.url);\n        imageDescriptions.push(description);\n      }\n\n      let state = await this.runtime.composeState(message, {\n        twitterClient: this.client.twitterClient,\n        twitterUserName: this.twitterUsername,\n        timeline: formattedHomeTimeline,\n        tweetContext: `${tweetBackground}\n\n  Original Post:\n  By @${selectedTweet.username}\n  ${selectedTweet.text}${replyContext.length > 0 && `\\nReplies to original post:\\n${replyContext}`}\n  ${`Original post text: ${selectedTweet.text}`}\n  ${selectedTweet.urls.length > 0 ? `URLs: ${selectedTweet.urls.join(', ')}\\n` : ''}${imageDescriptions.length > 0 ? `\\nImages in Post (Described): ${imageDescriptions.join(', ')}\\n` : ''}\n  `,\n      });\n\n      await this.client.saveRequestMessage(message, state as State);\n\n      const context = composeContext({\n        state,\n        template:\n          this.runtime.character.templates?.twitterSearchTemplate ||\n          twitterSearchTemplate,\n      });\n\n      const responseContent = await generateMessageResponse({\n        runtime: this.runtime,\n        context,\n        modelClass: ModelClass.LARGE,\n      });\n\n      responseContent.inReplyTo = message.id;\n\n      const response = responseContent;\n\n      if (!response.text) {\n        this.logger.warn('Returning: No response text found');\n        return;\n      }\n\n      this.logger.log(\n        `Bot would respond to tweet ${selectedTweet.id} with: ${response.text}`,\n      );\n      try {\n        const callback: HandlerCallback = async (response: Content) => {\n          const memories = await sendTweet(\n            this.client,\n            response,\n            message.roomId,\n            this.twitterUsername,\n            selectedTweet.id,\n          );\n          return memories;\n        };\n\n        const responseMessages = await callback(responseContent);\n\n        state = await this.runtime.updateRecentMessageState(state);\n\n        for (const responseMessage of responseMessages) {\n          await this.runtime.messageManager.createMemory(\n            responseMessage,\n            false,\n          );\n        }\n\n        state = await this.runtime.updateRecentMessageState(state);\n\n        await this.runtime.evaluate(message, state);\n\n        await this.runtime.processActions(\n          message,\n          responseMessages,\n          state,\n          callback,\n        );\n\n        this.respondedTweets.add(selectedTweet.id);\n        const responseInfo = `Context:\\n\\n${context}\\n\\nSelected Post: ${selectedTweet.id} - ${selectedTweet.username}: ${selectedTweet.text}\\nAgent's Output:\\n${response.text}`;\n\n        await this.runtime.cacheManager.set(\n          `twitter/tweet_generation_${selectedTweet.id}.txt`,\n          responseInfo,\n        );\n\n        await wait();\n      } catch (error) {\n        console.error(`Error sending response post: ${error}`);\n      }\n    } catch (error) {\n      console.error('Error engaging with search terms:', error);\n    }\n  }\n}\n","import {\n  type IAgentRuntime,\n  composeContext,\n  generateText,\n  ModelClass,\n  ServiceType,\n  type ITranscriptionService,\n  type TwitterSpaceDecisionOptions,\n} from '@elizaos/core';\nimport type { ClientBase } from './base';\nimport {\n  Space,\n  type SpaceConfig,\n  RecordToDiskPlugin,\n  IdleMonitorPlugin,\n  type SpeakerRequest,\n} from 'agent-twitter-client';\nimport { SttTtsPlugin } from './plugins/SttTtsSpacesPlugin.js';\nimport { CustomScraper } from './scraper.js';\nimport pino from 'pino';\n\ninterface CurrentSpeakerState {\n  userId: string;\n  sessionUUID: string;\n  username: string;\n  startTime: number;\n}\n\n/**\n * Generate short filler text via GPT\n */\nasync function generateFiller(\n  runtime: IAgentRuntime,\n  fillerType: string,\n): Promise<string> {\n  try {\n    const context = composeContext({\n      state: { fillerType },\n      template: `\n# INSTRUCTIONS:\nYou are generating a short filler message for a Twitter Space. The filler type is \"{{fillerType}}\".\nKeep it brief, friendly, and relevant. No more than two sentences.\nOnly return the text, no additional formatting.\n\n---\n`,\n    });\n    const output = await generateText({\n      runtime,\n      context,\n      modelClass: ModelClass.SMALL,\n    });\n    return output.trim();\n  } catch (err) {\n    this.logger.error('[generateFiller] Error generating filler:', err);\n    return '';\n  }\n}\n\n/**\n * Speak a filler message if STT/TTS plugin is available. Sleep a bit after TTS to avoid cutoff.\n */\nasync function speakFiller(\n  runtime: IAgentRuntime,\n  sttTtsPlugin: SttTtsPlugin | undefined,\n  fillerType: string,\n  sleepAfterMs = 3000,\n): Promise<void> {\n  if (!sttTtsPlugin) return;\n  const text = await generateFiller(runtime, fillerType);\n  if (!text) return;\n\n  this.logger.log(`[Space] Filler (${fillerType}) => ${text}`);\n  await sttTtsPlugin.speakText(text);\n\n  if (sleepAfterMs > 0) {\n    await new Promise((res) => setTimeout(res, sleepAfterMs));\n  }\n}\n\n/**\n * Generate topic suggestions via GPT if no topics are configured\n */\nasync function generateTopicsIfEmpty(\n  runtime: IAgentRuntime,\n): Promise<string[]> {\n  try {\n    const context = composeContext({\n      state: {},\n      template: `\n# INSTRUCTIONS:\nPlease generate 5 short topic ideas for a Twitter Space about technology or random interesting subjects.\nReturn them as a comma-separated list, no additional formatting or numbering.\n\nExample:\n\"AI Advances, Futuristic Gadgets, Space Exploration, Quantum Computing, Digital Ethics\"\n---\n`,\n    });\n    const response = await generateText({\n      runtime,\n      context,\n      modelClass: ModelClass.SMALL,\n    });\n    const topics = response\n      .split(',')\n      .map((t) => t.trim())\n      .filter(Boolean);\n    return topics.length ? topics : ['Random Tech Chat', 'AI Thoughts'];\n  } catch (err) {\n    this.logger.error('[generateTopicsIfEmpty] GPT error =>', err);\n    return ['Random Tech Chat', 'AI Thoughts'];\n  }\n}\n\n/**\n * Main class: manage a Twitter Space with N speakers max, speaker queue, filler messages, etc.\n */\nexport class TwitterSpaceClient {\n  private runtime: IAgentRuntime;\n  private client: ClientBase;\n  private scraper: CustomScraper;\n  private isSpaceRunning = false;\n  private currentSpace?: Space;\n  private spaceId?: string;\n  private startedAt?: number;\n  private checkInterval?: NodeJS.Timeout;\n  private lastSpaceEndedAt?: number;\n  private sttTtsPlugin?: SttTtsPlugin;\n\n  /**\n   * We now store an array of active speakers, not just 1\n   */\n  private activeSpeakers: CurrentSpeakerState[] = [];\n  private speakerQueue: SpeakerRequest[] = [];\n\n  private decisionOptions: TwitterSpaceDecisionOptions;\n  private logger: pino.Logger<string, boolean>;\n\n  constructor(client: ClientBase, runtime: IAgentRuntime) {\n    this.client = client;\n    this.scraper = client.twitterClient;\n    this.runtime = runtime;\n    this.logger = client.logger;\n\n    const charSpaces = runtime.character.twitterSpaces || {};\n    this.decisionOptions = {\n      maxSpeakers: charSpaces.maxSpeakers ?? 1,\n      topics: charSpaces.topics ?? [],\n      typicalDurationMinutes: charSpaces.typicalDurationMinutes ?? 30,\n      idleKickTimeoutMs: charSpaces.idleKickTimeoutMs ?? 5 * 60_000,\n      minIntervalBetweenSpacesMinutes:\n        charSpaces.minIntervalBetweenSpacesMinutes ?? 60,\n      businessHoursOnly: charSpaces.businessHoursOnly ?? false,\n      randomChance: charSpaces.randomChance ?? 0.3,\n      enableIdleMonitor: charSpaces.enableIdleMonitor !== false,\n      enableSttTts: charSpaces.enableSttTts !== false,\n      enableRecording: charSpaces.enableRecording !== false,\n      voiceId:\n        charSpaces.voiceId ||\n        runtime.character.settings.voice.model ||\n        'Xb7hH8MSUJpSbSDYk0k2',\n      sttLanguage: charSpaces.sttLanguage || 'en',\n      speakerMaxDurationMs: charSpaces.speakerMaxDurationMs ?? 4 * 60_000,\n    };\n  }\n\n  /**\n   * Periodic check to launch or manage space\n   */\n  public async startPeriodicSpaceCheck() {\n    this.logger.log('[Space] Starting periodic check routine...');\n\n    // For instance:\n    const intervalMsWhenIdle = 5 * 60_000; // 5 minutes if no Space is running\n    const intervalMsWhenRunning = 5_000; // 5 seconds if a Space IS running\n\n    const routine = async () => {\n      try {\n        if (!this.isSpaceRunning) {\n          // Space not running => check if we should launch\n          const launch = await this.shouldLaunchSpace();\n          if (launch) {\n            const config = await this.generateSpaceConfig();\n            await this.startSpace(config);\n          }\n          // Plan next iteration with a slower pace\n          this.checkInterval = setTimeout(\n            routine,\n            this.isSpaceRunning ? intervalMsWhenRunning : intervalMsWhenIdle,\n          );\n        } else {\n          // Space is running => manage it more frequently\n          await this.manageCurrentSpace();\n          // Plan next iteration with a faster pace\n          this.checkInterval = setTimeout(routine, intervalMsWhenRunning);\n        }\n      } catch (error) {\n        this.logger.error('[Space] Error in routine =>', error);\n        // In case of error, still schedule next iteration\n        this.checkInterval = setTimeout(routine, intervalMsWhenIdle);\n      }\n    };\n\n    routine();\n  }\n\n  stopPeriodicCheck() {\n    if (this.checkInterval) {\n      clearTimeout(this.checkInterval);\n      this.checkInterval = undefined;\n    }\n  }\n\n  private async shouldLaunchSpace(): Promise<boolean> {\n    // Random chance\n    const r = Math.random();\n    if (r > (this.decisionOptions.randomChance ?? 0.3)) {\n      this.logger.log('[Space] Random check => skip launching');\n      return false;\n    }\n    // Business hours\n    if (this.decisionOptions.businessHoursOnly) {\n      const hour = new Date().getUTCHours();\n      if (hour < 9 || hour >= 17) {\n        this.logger.log('[Space] Out of business hours => skip');\n        return false;\n      }\n    }\n    // Interval\n    const now = Date.now();\n    if (this.lastSpaceEndedAt) {\n      const minIntervalMs =\n        (this.decisionOptions.minIntervalBetweenSpacesMinutes ?? 60) * 60_000;\n      if (now - this.lastSpaceEndedAt < minIntervalMs) {\n        this.logger.log('[Space] Too soon since last space => skip');\n        return false;\n      }\n    }\n\n    this.logger.log('[Space] Deciding to launch a new Space...');\n    return true;\n  }\n\n  private async generateSpaceConfig(): Promise<SpaceConfig> {\n    if (\n      !this.decisionOptions.topics ||\n      this.decisionOptions.topics.length === 0\n    ) {\n      const newTopics = await generateTopicsIfEmpty(this.client.runtime);\n      this.decisionOptions.topics = newTopics;\n    }\n\n    let chosenTopic = 'Random Tech Chat';\n    if (this.decisionOptions.topics && this.decisionOptions.topics.length > 0) {\n      chosenTopic =\n        this.decisionOptions.topics[\n          Math.floor(Math.random() * this.decisionOptions.topics.length)\n        ];\n    }\n\n    return {\n      mode: 'INTERACTIVE',\n      title: chosenTopic,\n      description: `Discussion about ${chosenTopic}`,\n      languages: ['en'],\n    };\n  }\n\n  public async startSpace(config: SpaceConfig) {\n    this.logger.log('[Space] Starting a new Twitter Space...');\n\n    try {\n      this.currentSpace = new Space(this.scraper);\n      this.isSpaceRunning = false;\n      this.spaceId = undefined;\n      this.startedAt = Date.now();\n\n      // Reset states\n      this.activeSpeakers = [];\n      this.speakerQueue = [];\n\n      // Retrieve keys\n      const elevenLabsKey =\n        this.runtime.getSetting('ELEVENLABS_XI_API_KEY') || '';\n\n      const broadcastInfo = await this.currentSpace.initialize(config);\n      this.spaceId = broadcastInfo.room_id;\n      // Plugins\n      if (this.decisionOptions.enableRecording) {\n        this.logger.log('[Space] Using RecordToDiskPlugin');\n        this.currentSpace.use(new RecordToDiskPlugin());\n      }\n\n      if (this.decisionOptions.enableSttTts) {\n        this.logger.log('[Space] Using SttTtsPlugin');\n        const sttTts = new SttTtsPlugin();\n        this.sttTtsPlugin = sttTts;\n        this.currentSpace.use(sttTts, {\n          runtime: this.runtime,\n          client: this.client,\n          spaceId: this.spaceId,\n          elevenLabsApiKey: elevenLabsKey,\n          voiceId: this.decisionOptions.voiceId,\n          sttLanguage: this.decisionOptions.sttLanguage,\n          transcriptionService:\n            this.client.runtime.getService<ITranscriptionService>(\n              ServiceType.TRANSCRIPTION,\n            ),\n        });\n      }\n\n      if (this.decisionOptions.enableIdleMonitor) {\n        this.logger.log('[Space] Using IdleMonitorPlugin');\n        this.currentSpace.use(\n          new IdleMonitorPlugin(\n            this.decisionOptions.idleKickTimeoutMs ?? 60_000,\n            10_000,\n          ),\n        );\n      }\n\n      this.isSpaceRunning = true;\n      await this.scraper.sendTweet(\n        broadcastInfo.share_url.replace('broadcasts', 'spaces'),\n      );\n\n      const spaceUrl = broadcastInfo.share_url.replace('broadcasts', 'spaces');\n      this.logger.log(`[Space] Space started => ${spaceUrl}`);\n\n      // Greet\n      await speakFiller(this.client.runtime, this.sttTtsPlugin, 'WELCOME');\n\n      // Events\n      this.currentSpace.on('occupancyUpdate', (update) => {\n        this.logger.log(\n          `[Space] Occupancy => ${update.occupancy} participant(s).`,\n        );\n      });\n\n      this.currentSpace.on('speakerRequest', async (req: SpeakerRequest) => {\n        this.logger.log(\n          `[Space] Speaker request from @${req.username} (${req.userId}).`,\n        );\n        await this.handleSpeakerRequest(req);\n      });\n\n      this.currentSpace.on('idleTimeout', async (info) => {\n        this.logger.log(\n          `[Space] idleTimeout => no audio for ${info.idleMs} ms.`,\n        );\n        await speakFiller(\n          this.client.runtime,\n          this.sttTtsPlugin,\n          'IDLE_ENDING',\n        );\n        await this.stopSpace();\n      });\n\n      process.on('SIGINT', async () => {\n        this.logger.log('[Space] SIGINT => stopping space');\n        await speakFiller(this.client.runtime, this.sttTtsPlugin, 'CLOSING');\n        await this.stopSpace();\n        process.exit(0);\n      });\n    } catch (error) {\n      this.logger.error('[Space] Error launching Space =>', error);\n      this.isSpaceRunning = false;\n      throw error;\n    }\n  }\n\n  /**\n   * Periodic management: check durations, remove extras, maybe accept new from queue\n   */\n  private async manageCurrentSpace() {\n    if (!this.spaceId || !this.currentSpace) return;\n    try {\n      const audioSpace = await this.scraper.getAudioSpaceById(this.spaceId);\n      const { participants } = audioSpace;\n      const numSpeakers = participants.speakers?.length || 0;\n      const totalListeners = participants.listeners?.length || 0;\n\n      // 1) Remove any speaker who exceeded speakerMaxDurationMs\n      const maxDur = this.decisionOptions.speakerMaxDurationMs ?? 240_000;\n      const now = Date.now();\n\n      for (let i = this.activeSpeakers.length - 1; i >= 0; i--) {\n        const speaker = this.activeSpeakers[i];\n        const elapsed = now - speaker.startTime;\n        if (elapsed > maxDur) {\n          this.logger.log(\n            `[Space] Speaker @${speaker.username} exceeded max duration => removing`,\n          );\n          await this.removeSpeaker(speaker.userId);\n          this.activeSpeakers.splice(i, 1);\n\n          // Possibly speak a short \"SPEAKER_LEFT\" filler\n          await speakFiller(\n            this.client.runtime,\n            this.sttTtsPlugin,\n            'SPEAKER_LEFT',\n          );\n        }\n      }\n\n      // 2) If we have capacity for new speakers from the queue, accept them\n      await this.acceptSpeakersFromQueueIfNeeded();\n\n      // 3) If somehow more than maxSpeakers are active, remove the extras\n      if (numSpeakers > (this.decisionOptions.maxSpeakers ?? 1)) {\n        this.logger.log('[Space] More than maxSpeakers => removing extras...');\n        await this.kickExtraSpeakers(participants.speakers);\n      }\n\n      // 4) Possibly stop the space if empty or time exceeded\n      const elapsedMinutes = (now - (this.startedAt || 0)) / 60000;\n      if (\n        elapsedMinutes > (this.decisionOptions.typicalDurationMinutes ?? 30) ||\n        (numSpeakers === 0 && totalListeners === 0 && elapsedMinutes > 5)\n      ) {\n        this.logger.log('[Space] Condition met => stopping the Space...');\n        await speakFiller(\n          this.client.runtime,\n          this.sttTtsPlugin,\n          'CLOSING',\n          4000,\n        );\n        await this.stopSpace();\n      }\n    } catch (error) {\n      this.logger.error('[Space] Error in manageCurrentSpace =>', error);\n    }\n  }\n\n  /**\n   * If we have available slots, accept new speakers from the queue\n   */\n  private async acceptSpeakersFromQueueIfNeeded() {\n    // while queue not empty and activeSpeakers < maxSpeakers, accept next\n    const ms = this.decisionOptions.maxSpeakers ?? 1;\n    while (this.speakerQueue.length > 0 && this.activeSpeakers.length < ms) {\n      const nextReq = this.speakerQueue.shift();\n      if (nextReq) {\n        await speakFiller(this.client.runtime, this.sttTtsPlugin, 'PRE_ACCEPT');\n        await this.acceptSpeaker(nextReq);\n      }\n    }\n  }\n\n  private async handleSpeakerRequest(req: SpeakerRequest) {\n    if (!this.spaceId || !this.currentSpace) return;\n\n    const audioSpace = await this.scraper.getAudioSpaceById(this.spaceId);\n    const janusSpeakers = audioSpace?.participants?.speakers || [];\n\n    // If we haven't reached maxSpeakers, accept immediately\n    if (janusSpeakers.length < (this.decisionOptions.maxSpeakers ?? 1)) {\n      this.logger.log(`[Space] Accepting speaker @${req.username} now`);\n      await speakFiller(this.client.runtime, this.sttTtsPlugin, 'PRE_ACCEPT');\n      await this.acceptSpeaker(req);\n    } else {\n      this.logger.log(`[Space] Adding speaker @${req.username} to the queue`);\n      this.speakerQueue.push(req);\n    }\n  }\n\n  private async acceptSpeaker(req: SpeakerRequest) {\n    if (!this.currentSpace) return;\n    try {\n      await this.currentSpace.approveSpeaker(req.userId, req.sessionUUID);\n      this.activeSpeakers.push({\n        userId: req.userId,\n        sessionUUID: req.sessionUUID,\n        username: req.username,\n        startTime: Date.now(),\n      });\n      this.logger.log(`[Space] Speaker @${req.username} is now live`);\n    } catch (err) {\n      this.logger.error(\n        `[Space] Error approving speaker @${req.username}:`,\n        err,\n      );\n    }\n  }\n\n  private async removeSpeaker(userId: string) {\n    if (!this.currentSpace) return;\n    try {\n      await this.currentSpace.removeSpeaker(userId);\n      this.logger.log(`[Space] Removed speaker userId=${userId}`);\n    } catch (error) {\n      this.logger.error(\n        `[Space] Error removing speaker userId=${userId} =>`,\n        error,\n      );\n    }\n  }\n\n  /**\n   * If more than maxSpeakers are found, remove extras\n   * Also update activeSpeakers array\n   */\n  private async kickExtraSpeakers(speakers: any[]) {\n    if (!this.currentSpace) return;\n    const ms = this.decisionOptions.maxSpeakers ?? 1;\n\n    // sort by who joined first if needed, or just slice\n    const extras = speakers.slice(ms);\n    for (const sp of extras) {\n      this.logger.log(`[Space] Removing extra speaker => userId=${sp.user_id}`);\n      await this.removeSpeaker(sp.user_id);\n\n      // remove from activeSpeakers array\n      const idx = this.activeSpeakers.findIndex((s) => s.userId === sp.user_id);\n      if (idx !== -1) {\n        this.activeSpeakers.splice(idx, 1);\n      }\n    }\n  }\n\n  public async stopSpace() {\n    if (!this.currentSpace || !this.isSpaceRunning) return;\n    try {\n      this.logger.log('[Space] Stopping the current Space...');\n      await this.currentSpace.stop();\n    } catch (err) {\n      this.logger.error('[Space] Error stopping Space =>', err);\n    } finally {\n      this.isSpaceRunning = false;\n      this.spaceId = undefined;\n      this.currentSpace = undefined;\n      this.startedAt = undefined;\n      this.lastSpaceEndedAt = Date.now();\n      this.activeSpeakers = [];\n      this.speakerQueue = [];\n    }\n  }\n}\n","// src/plugins/SttTtsPlugin.js\n\nimport { spawn } from 'child_process';\nimport {\n  type ITranscriptionService,\n  elizaLogger,\n  stringToUuid,\n  composeContext,\n  getEmbeddingZeroVector,\n  generateMessageResponse,\n  ModelClass,\n  type Content,\n  type IAgentRuntime,\n  type Memory,\n  type Plugin,\n  type State,\n  composeRandomUser,\n  generateShouldRespond,\n} from '@elizaos/core';\nimport type {\n  Space,\n  JanusClient,\n  AudioDataWithUser,\n} from 'agent-twitter-client';\nimport type { ClientBase } from '../base';\nimport {\n  twitterVoiceHandlerTemplate,\n  twitterShouldRespondTemplate,\n} from './templates';\n\ninterface PluginConfig {\n  runtime: IAgentRuntime;\n  client: ClientBase;\n  spaceId: string;\n  elevenLabsApiKey?: string; // for TTS\n  sttLanguage?: string; // e.g. \"en\" for Whisper\n  silenceThreshold?: number; // amplitude threshold for ignoring silence\n  voiceId?: string; // specify which ElevenLabs voice to use\n  elevenLabsModel?: string; // e.g. \"eleven_monolingual_v1\"\n  chatContext?: Array<{\n    role: 'system' | 'user' | 'assistant';\n    content: string;\n  }>;\n  transcriptionService: ITranscriptionService;\n}\n\nconst VOLUME_WINDOW_SIZE = 100;\nconst SPEAKING_THRESHOLD = 0.05;\nconst SILENCE_DETECTION_THRESHOLD_MS = 1000; // 1-second silence threshold\n\n/**\n * MVP plugin for speech-to-text (OpenAI) + conversation + TTS (ElevenLabs)\n * Approach:\n *   - Collect each speaker's unmuted PCM in a memory buffer (only if above silence threshold)\n *   - On speaker mute -> flush STT -> GPT -> TTS -> push to Janus\n */\nexport class SttTtsPlugin implements Plugin {\n  name = 'SttTtsPlugin';\n  description = 'Speech-to-text (OpenAI) + conversation + TTS (ElevenLabs)';\n  private runtime: IAgentRuntime;\n  private client: ClientBase;\n  private spaceId: string;\n\n  private space?: Space;\n  private janus?: JanusClient;\n\n  private elevenLabsApiKey?: string;\n\n  private voiceId = '21m00Tcm4TlvDq8ikWAM';\n  private elevenLabsModel = 'eleven_monolingual_v1';\n  private chatContext: Array<{\n    role: 'system' | 'user' | 'assistant';\n    content: string;\n  }> = [];\n\n  private transcriptionService: ITranscriptionService;\n\n  /**\n   * userId => arrayOfChunks (PCM Int16)\n   */\n  private pcmBuffers = new Map<string, Int16Array[]>();\n\n  /**\n   * For ignoring near-silence frames (if amplitude < threshold)\n   */\n  private silenceThreshold = 50;\n\n  // TTS queue for sequentially speaking\n  private ttsQueue: string[] = [];\n  private isSpeaking = false;\n  private isProcessingAudio = false;\n\n  private userSpeakingTimer: NodeJS.Timeout | null = null;\n  private volumeBuffers: Map<string, number[]>;\n  private ttsAbortController: AbortController | null = null;\n\n  onAttach(_space: Space) {\n    elizaLogger.log('[SttTtsPlugin] onAttach => space was attached');\n  }\n\n  init(params: { space: Space; pluginConfig?: Record<string, any> }): void {\n    elizaLogger.log(\n      '[SttTtsPlugin] init => Space fully ready. Subscribing to events.',\n    );\n\n    this.space = params.space;\n    this.janus = (this.space as any)?.janusClient as JanusClient | undefined;\n\n    const config = params.pluginConfig as PluginConfig;\n    this.runtime = config?.runtime;\n    this.client = config?.client;\n    this.spaceId = config?.spaceId;\n    this.elevenLabsApiKey = config?.elevenLabsApiKey;\n    this.transcriptionService = config.transcriptionService;\n    if (typeof config?.silenceThreshold === 'number') {\n      this.silenceThreshold = config.silenceThreshold;\n    }\n    if (config?.voiceId) {\n      this.voiceId = config.voiceId;\n    }\n    if (config?.elevenLabsModel) {\n      this.elevenLabsModel = config.elevenLabsModel;\n    }\n    if (config?.chatContext) {\n      this.chatContext = config.chatContext;\n    }\n\n    this.volumeBuffers = new Map<string, number[]>();\n  }\n\n  /**\n   * Called whenever we receive PCM from a speaker\n   */\n  onAudioData(data: AudioDataWithUser): void {\n    if (this.isProcessingAudio) {\n      return;\n    }\n    let maxVal = 0;\n    for (let i = 0; i < data.samples.length; i++) {\n      const val = Math.abs(data.samples[i]);\n      if (val > maxVal) maxVal = val;\n    }\n    if (maxVal < this.silenceThreshold) {\n      return;\n    }\n\n    if (this.userSpeakingTimer) {\n      clearTimeout(this.userSpeakingTimer);\n    }\n\n    let arr = this.pcmBuffers.get(data.userId);\n    if (!arr) {\n      arr = [];\n      this.pcmBuffers.set(data.userId, arr);\n    }\n    arr.push(data.samples);\n\n    if (!this.isSpeaking) {\n      this.userSpeakingTimer = setTimeout(() => {\n        elizaLogger.log(\n          '[SttTtsPlugin] start processing audio for user =>',\n          data.userId,\n        );\n        this.userSpeakingTimer = null;\n        this.processAudio(data.userId).catch((err) =>\n          elizaLogger.error('[SttTtsPlugin] handleSilence error =>', err),\n        );\n      }, SILENCE_DETECTION_THRESHOLD_MS);\n    } else {\n      // check interruption\n      let volumeBuffer = this.volumeBuffers.get(data.userId);\n      if (!volumeBuffer) {\n        volumeBuffer = [];\n        this.volumeBuffers.set(data.userId, volumeBuffer);\n      }\n      const samples = new Int16Array(\n        data.samples.buffer,\n        data.samples.byteOffset,\n        data.samples.length / 2,\n      );\n      const maxAmplitude = Math.max(...samples.map(Math.abs)) / 32768;\n      volumeBuffer.push(maxAmplitude);\n\n      if (volumeBuffer.length > VOLUME_WINDOW_SIZE) {\n        volumeBuffer.shift();\n      }\n      const avgVolume =\n        volumeBuffer.reduce((sum, v) => sum + v, 0) / VOLUME_WINDOW_SIZE;\n\n      if (avgVolume > SPEAKING_THRESHOLD) {\n        volumeBuffer.length = 0;\n        if (this.ttsAbortController) {\n          this.ttsAbortController.abort();\n          this.isSpeaking = false;\n          elizaLogger.log('[SttTtsPlugin] TTS playback interrupted');\n        }\n      }\n    }\n  }\n\n  // /src/sttTtsPlugin.js\n  private async convertPcmToWavInMemory(\n    pcmData: Int16Array,\n    sampleRate: number,\n  ): Promise<ArrayBuffer> {\n    // number of channels\n    const numChannels = 1;\n    // byte rate = (sampleRate * numChannels * bitsPerSample/8)\n    const byteRate = sampleRate * numChannels * 2;\n    const blockAlign = numChannels * 2;\n    // data chunk size = pcmData.length * (bitsPerSample/8)\n    const dataSize = pcmData.length * 2;\n\n    // WAV header is 44 bytes\n    const buffer = new ArrayBuffer(44 + dataSize);\n    const view = new DataView(buffer);\n\n    // RIFF chunk descriptor\n    this.writeString(view, 0, 'RIFF');\n    view.setUint32(4, 36 + dataSize, true); // file size - 8\n    this.writeString(view, 8, 'WAVE');\n\n    // fmt sub-chunk\n    this.writeString(view, 12, 'fmt ');\n    view.setUint32(16, 16, true); // Subchunk1Size (16 for PCM)\n    view.setUint16(20, 1, true); // AudioFormat (1 = PCM)\n    view.setUint16(22, numChannels, true); // NumChannels\n    view.setUint32(24, sampleRate, true); // SampleRate\n    view.setUint32(28, byteRate, true); // ByteRate\n    view.setUint16(32, blockAlign, true); // BlockAlign\n    view.setUint16(34, 16, true); // BitsPerSample (16)\n\n    // data sub-chunk\n    this.writeString(view, 36, 'data');\n    view.setUint32(40, dataSize, true);\n\n    // Write PCM samples\n    let offset = 44;\n    for (let i = 0; i < pcmData.length; i++, offset += 2) {\n      view.setInt16(offset, pcmData[i], true);\n    }\n\n    return buffer;\n  }\n\n  private writeString(view: DataView, offset: number, text: string) {\n    for (let i = 0; i < text.length; i++) {\n      view.setUint8(offset + i, text.charCodeAt(i));\n    }\n  }\n\n  /**\n   * On speaker silence => flush STT => GPT => TTS => push to Janus\n   */\n  private async processAudio(userId: string): Promise<void> {\n    if (this.isProcessingAudio) {\n      return;\n    }\n    this.isProcessingAudio = true;\n    try {\n      elizaLogger.log(\n        '[SttTtsPlugin] Starting audio processing for user:',\n        userId,\n      );\n      const chunks = this.pcmBuffers.get(userId) || [];\n      this.pcmBuffers.clear();\n\n      if (!chunks.length) {\n        elizaLogger.warn('[SttTtsPlugin] No audio chunks for user =>', userId);\n        return;\n      }\n      elizaLogger.log(\n        `[SttTtsPlugin] Flushing STT buffer for user=${userId}, chunks=${chunks.length}`,\n      );\n\n      const totalLen = chunks.reduce((acc, c) => acc + c.length, 0);\n      const merged = new Int16Array(totalLen);\n      let offset = 0;\n      for (const c of chunks) {\n        merged.set(c, offset);\n        offset += c.length;\n      }\n\n      // Convert PCM to WAV for STT\n      const wavBuffer = await this.convertPcmToWavInMemory(merged, 48000);\n\n      // Whisper STT\n      const sttText = await this.transcriptionService.transcribe(wavBuffer);\n\n      elizaLogger.log(`[SttTtsPlugin] Transcription result: \"${sttText}\"`);\n\n      if (!sttText || !sttText.trim()) {\n        elizaLogger.warn(\n          '[SttTtsPlugin] No speech recognized for user =>',\n          userId,\n        );\n        return;\n      }\n      elizaLogger.log(\n        `[SttTtsPlugin] STT => user=${userId}, text=\"${sttText}\"`,\n      );\n\n      // Get response\n      const replyText = await this.handleUserMessage(sttText, userId);\n      if (!replyText || !replyText.length || !replyText.trim()) {\n        elizaLogger.warn('[SttTtsPlugin] No replyText for user =>', userId);\n        return;\n      }\n      elizaLogger.log(`[SttTtsPlugin] user=${userId}, reply=\"${replyText}\"`);\n      this.isProcessingAudio = false;\n      this.volumeBuffers.clear();\n      // Use the standard speak method with queue\n      await this.speakText(replyText);\n    } catch (error) {\n      elizaLogger.error('[SttTtsPlugin] processAudio error =>', error);\n    } finally {\n      this.isProcessingAudio = false;\n    }\n  }\n\n  /**\n   * Public method to queue a TTS request\n   */\n  public async speakText(text: string): Promise<void> {\n    this.ttsQueue.push(text);\n    if (!this.isSpeaking) {\n      this.isSpeaking = true;\n      this.processTtsQueue().catch((err) => {\n        elizaLogger.error('[SttTtsPlugin] processTtsQueue error =>', err);\n      });\n    }\n  }\n\n  /**\n   * Process TTS requests one by one\n   */\n  private async processTtsQueue(): Promise<void> {\n    while (this.ttsQueue.length > 0) {\n      const text = this.ttsQueue.shift();\n      if (!text) continue;\n\n      this.ttsAbortController = new AbortController();\n      const { signal } = this.ttsAbortController;\n\n      try {\n        const ttsAudio = await this.elevenLabsTts(text);\n        const pcm = await this.convertMp3ToPcm(ttsAudio, 48000);\n        if (signal.aborted) {\n          elizaLogger.log('[SttTtsPlugin] TTS interrupted before streaming');\n          return;\n        }\n        await this.streamToJanus(pcm, 48000);\n        if (signal.aborted) {\n          elizaLogger.log('[SttTtsPlugin] TTS interrupted after streaming');\n          return;\n        }\n      } catch (err) {\n        elizaLogger.error('[SttTtsPlugin] TTS streaming error =>', err);\n      } finally {\n        // Clean up the AbortController\n        this.ttsAbortController = null;\n      }\n    }\n    this.isSpeaking = false;\n  }\n\n  /**\n   * Handle User Message\n   */\n  private async handleUserMessage(\n    userText: string,\n    userId: string, // This is the raw Twitter user ID like 'tw-1865462035586142208'\n  ): Promise<string> {\n    // Extract the numeric ID part\n    const numericId = userId.replace('tw-', '');\n    const roomId = stringToUuid(`twitter_generate_room-${this.spaceId}`);\n\n    // Create consistent UUID for the user\n    const userUuid = stringToUuid(`twitter-user-${numericId}`);\n\n    // Ensure the user exists in the accounts table\n    await this.runtime.ensureUserExists(\n      userUuid,\n      userId, // Use full Twitter ID as username\n      `Twitter User ${numericId}`,\n      'twitter',\n    );\n\n    // Ensure room exists and user is in it\n    await this.runtime.ensureRoomExists(roomId);\n    await this.runtime.ensureParticipantInRoom(userUuid, roomId);\n\n    let state = await this.runtime.composeState(\n      {\n        agentId: this.runtime.agentId,\n        content: { text: userText, source: 'twitter' },\n        userId: userUuid,\n        roomId,\n      },\n      {\n        twitterUserName: this.client.profile.username,\n        agentName: this.runtime.character.name,\n      },\n    );\n\n    const memory = {\n      id: stringToUuid(`${roomId}-voice-message-${Date.now()}`),\n      agentId: this.runtime.agentId,\n      content: {\n        text: userText,\n        source: 'twitter',\n      },\n      userId: userUuid,\n      roomId,\n      embedding: getEmbeddingZeroVector(),\n      createdAt: Date.now(),\n    };\n\n    await this.runtime.messageManager.createMemory(memory);\n\n    state = await this.runtime.updateRecentMessageState(state);\n\n    const shouldIgnore = await this._shouldIgnore(memory);\n\n    if (shouldIgnore) {\n      return '';\n    }\n\n    const shouldRespond = await this._shouldRespond(userText, state);\n\n    if (!shouldRespond) {\n      return '';\n    }\n\n    const context = composeContext({\n      state,\n      template:\n        this.runtime.character.templates?.twitterVoiceHandlerTemplate ||\n        this.runtime.character.templates?.messageHandlerTemplate ||\n        twitterVoiceHandlerTemplate,\n    });\n\n    const responseContent = await this._generateResponse(memory, context);\n\n    const responseMemory: Memory = {\n      id: stringToUuid(`${memory.id}-voice-response-${Date.now()}`),\n      agentId: this.runtime.agentId,\n      userId: this.runtime.agentId,\n      content: {\n        ...responseContent,\n        user: this.runtime.character.name,\n        inReplyTo: memory.id,\n      },\n      roomId,\n      embedding: getEmbeddingZeroVector(),\n    };\n\n    const reply = responseMemory.content.text?.trim();\n    if (reply) {\n      await this.runtime.messageManager.createMemory(responseMemory);\n    }\n\n    return reply;\n  }\n\n  private async _generateResponse(\n    message: Memory,\n    context: string,\n  ): Promise<Content> {\n    const { userId, roomId } = message;\n\n    const response = await generateMessageResponse({\n      runtime: this.runtime,\n      context,\n      modelClass: ModelClass.SMALL,\n    });\n\n    response.source = 'discord';\n\n    if (!response) {\n      elizaLogger.error(\n        '[SttTtsPlugin] No response from generateMessageResponse',\n      );\n      return;\n    }\n\n    await this.runtime.databaseAdapter.log({\n      body: { message, context, response },\n      userId: userId,\n      roomId,\n      type: 'response',\n    });\n\n    return response;\n  }\n\n  private async _shouldIgnore(message: Memory): Promise<boolean> {\n    elizaLogger.debug('message.content: ', message.content);\n    // if the message is 3 characters or less, ignore it\n    if ((message.content as Content).text.length < 3) {\n      return true;\n    }\n\n    const loseInterestWords = [\n      // telling the bot to stop talking\n      'shut up',\n      'stop',\n      'dont talk',\n      'silence',\n      'stop talking',\n      'be quiet',\n      'hush',\n      'stfu',\n      'stupid bot',\n      'dumb bot',\n\n      // offensive words\n      'fuck',\n      'shit',\n      'damn',\n      'suck',\n      'dick',\n      'cock',\n      'sex',\n      'sexy',\n    ];\n    if (\n      (message.content as Content).text.length < 50 &&\n      loseInterestWords.some((word) =>\n        (message.content as Content).text?.toLowerCase().includes(word),\n      )\n    ) {\n      return true;\n    }\n\n    const ignoreWords = ['k', 'ok', 'bye', 'lol', 'nm', 'uh'];\n    if (\n      (message.content as Content).text?.length < 8 &&\n      ignoreWords.some((word) =>\n        (message.content as Content).text?.toLowerCase().includes(word),\n      )\n    ) {\n      return true;\n    }\n\n    return false;\n  }\n\n  private async _shouldRespond(\n    message: string,\n    state: State,\n  ): Promise<boolean> {\n    const lowerMessage = message.toLowerCase();\n    const characterName = this.runtime.character.name.toLowerCase();\n\n    if (lowerMessage.includes(characterName)) {\n      return true;\n    }\n\n    // If none of the above conditions are met, use the generateText to decide\n    const shouldRespondContext = composeContext({\n      state,\n      template:\n        this.runtime.character.templates?.twitterShouldRespondTemplate ||\n        this.runtime.character.templates?.shouldRespondTemplate ||\n        composeRandomUser(twitterShouldRespondTemplate, 2),\n    });\n\n    const response = await generateShouldRespond({\n      runtime: this.runtime,\n      context: shouldRespondContext,\n      modelClass: ModelClass.SMALL,\n    });\n\n    if (response === 'RESPOND') {\n      return true;\n    }\n\n    if (response === 'IGNORE' || response === 'STOP') {\n      return false;\n    }\n\n    elizaLogger.error('Invalid response from response generateText:', response);\n    return false;\n  }\n\n  /**\n   * ElevenLabs TTS => returns MP3 Buffer\n   */\n  private async elevenLabsTts(text: string): Promise<Buffer> {\n    if (!this.elevenLabsApiKey) {\n      throw new Error('[SttTtsPlugin] No ElevenLabs API key');\n    }\n    const url = `https://api.elevenlabs.io/v1/text-to-speech/${this.voiceId}`;\n    const resp = await fetch(url, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'xi-api-key': this.elevenLabsApiKey,\n      },\n      body: JSON.stringify({\n        text,\n        model_id: this.elevenLabsModel,\n        voice_settings: { stability: 0.4, similarity_boost: 0.8 },\n      }),\n    });\n    if (!resp.ok) {\n      const errText = await resp.text();\n      throw new Error(\n        `[SttTtsPlugin] ElevenLabs TTS error => ${resp.status} ${errText}`,\n      );\n    }\n    const arrayBuf = await resp.arrayBuffer();\n    return Buffer.from(arrayBuf);\n  }\n\n  /**\n   * Convert MP3 => PCM via ffmpeg\n   */\n  private convertMp3ToPcm(\n    mp3Buf: Buffer,\n    outRate: number,\n  ): Promise<Int16Array> {\n    return new Promise((resolve, reject) => {\n      const ff = spawn('ffmpeg', [\n        '-i',\n        'pipe:0',\n        '-f',\n        's16le',\n        '-ar',\n        outRate.toString(),\n        '-ac',\n        '1',\n        'pipe:1',\n      ]);\n      let raw = Buffer.alloc(0);\n\n      ff.stdout.on('data', (chunk: Buffer) => {\n        raw = Buffer.concat([raw, chunk]);\n      });\n      ff.stderr.on('data', () => {\n        // ignoring ffmpeg logs\n      });\n      ff.on('close', (code) => {\n        if (code !== 0) {\n          reject(new Error(`ffmpeg error code=${code}`));\n          return;\n        }\n        const samples = new Int16Array(\n          raw.buffer,\n          raw.byteOffset,\n          raw.byteLength / 2,\n        );\n        resolve(samples);\n      });\n\n      ff.stdin.write(mp3Buf);\n      ff.stdin.end();\n    });\n  }\n\n  /**\n   * Push PCM back to Janus in small frames\n   * We'll do 10ms @48k => 960 samples per frame\n   */\n  private async streamToJanus(\n    samples: Int16Array,\n    sampleRate: number,\n  ): Promise<void> {\n    // TODO: Check if better than 480 fixed\n    const FRAME_SIZE = Math.floor(sampleRate * 0.01); // 10ms frames => 480 @48kHz\n\n    for (\n      let offset = 0;\n      offset + FRAME_SIZE <= samples.length;\n      offset += FRAME_SIZE\n    ) {\n      if (this.ttsAbortController?.signal.aborted) {\n        elizaLogger.log('[SttTtsPlugin] streamToJanus interrupted');\n        return;\n      }\n      const frame = new Int16Array(FRAME_SIZE);\n      frame.set(samples.subarray(offset, offset + FRAME_SIZE));\n      this.janus?.pushLocalAudio(frame, sampleRate, 1);\n\n      // Short pause so we don't overload\n      await new Promise((r) => setTimeout(r, 10));\n    }\n  }\n\n  /**\n   * Add a message (system, user or assistant) to the chat context.\n   * E.g. to store conversation history or inject a persona.\n   */\n  public addMessage(role: 'system' | 'user' | 'assistant', content: string) {\n    this.chatContext.push({ role, content });\n    elizaLogger.log(\n      `[SttTtsPlugin] addMessage => role=${role}, content=${content}`,\n    );\n  }\n\n  /**\n   * Clear the chat context if needed.\n   */\n  public clearChatContext() {\n    this.chatContext = [];\n    elizaLogger.log('[SttTtsPlugin] clearChatContext => done');\n  }\n\n  cleanup(): void {\n    elizaLogger.log('[SttTtsPlugin] cleanup => releasing resources');\n    this.pcmBuffers.clear();\n    this.userSpeakingTimer = null;\n    this.ttsQueue = [];\n    this.isSpeaking = false;\n    this.volumeBuffers.clear();\n  }\n}\n","import { messageCompletionFooter, shouldRespondFooter } from '@elizaos/core';\n\nexport const twitterShouldRespondTemplate =\n  `# Task: Decide if {{agentName}} should respond.\nAbout {{agentName}}:\n{{bio}}\n\n# INSTRUCTIONS: Determine if {{agentName}} should respond to the message and participate in the conversation. Do not comment. Just respond with \"RESPOND\" or \"IGNORE\" or \"STOP\".\n\n# RESPONSE EXAMPLES\n{{user1}}: I just saw a really great movie\n{{user2}}: Oh? Which movie?\nResult: [IGNORE]\n\n{{agentName}}: Oh, this is my favorite scene\n{{user1}}: sick\n{{user2}}: wait, why is it your favorite scene\nResult: [RESPOND]\n\n{{user1}}: stfu bot\nResult: [STOP]\n\n{{user1}}: Hey {{agent}}, can you help me with something\nResult: [RESPOND]\n\n{{user1}}: {{agentName}} stfu plz\nResult: [STOP]\n\n{{user1}}: i need help\n{{agentName}}: how can I help you?\n{{user1}}: no. i need help from someone else\nResult: [IGNORE]\n\n{{user1}}: Hey {{agent}}, can I ask you a question\n{{agentName}}: Sure, what is it\n{{user1}}: can you ask claude to create a basic react module that demonstrates a counter\nResult: [RESPOND]\n\n{{user1}}: {{agentName}} can you tell me a story\n{{user1}}: about a girl named elara\n{{agentName}}: Sure.\n{{agentName}}: Once upon a time, in a quaint little village, there was a curious girl named Elara.\n{{agentName}}: Elara was known for her adventurous spirit and her knack for finding beauty in the mundane.\n{{user1}}: I'm loving it, keep going\nResult: [RESPOND]\n\n{{user1}}: {{agentName}} stop responding plz\nResult: [STOP]\n\n{{user1}}: okay, i want to test something. can you say marco?\n{{agentName}}: marco\n{{user1}}: great. okay, now do it again\nResult: [RESPOND]\n\nResponse options are [RESPOND], [IGNORE] and [STOP].\n\n{{agentName}} is in a room with other users and is very worried about being annoying and saying too much.\nRespond with [RESPOND] to messages that are directed at {{agentName}}, or participate in conversations that are interesting or relevant to their background.\nIf a message is not interesting or relevant, respond with [IGNORE]\nUnless directly responding to a user, respond with [IGNORE] to messages that are very short or do not contain much information.\nIf a user asks {{agentName}} to be quiet, respond with [STOP]\nIf {{agentName}} concludes a conversation and isn't part of the conversation anymore, respond with [STOP]\n\nIMPORTANT: {{agentName}} is particularly sensitive about being annoying, so if there is any doubt, it is better to respond with [IGNORE].\nIf {{agentName}} is conversing with a user and they have not asked to stop, it is better to respond with [RESPOND].\n\n{{recentMessages}}\n\n# INSTRUCTIONS: Choose the option that best describes {{agentName}}'s response to the last message. Ignore messages if they are addressed to someone else.\n` + shouldRespondFooter;\n\nexport const twitterVoiceHandlerTemplate =\n  `# Task: Generate conversational voice dialog for {{agentName}}.\n    About {{agentName}}:\n    {{bio}}\n\n    # Attachments\n    {{attachments}}\n\n    # Capabilities\n    Note that {{agentName}} is capable of reading/seeing/hearing various forms of media, including images, videos, audio, plaintext and PDFs. Recent attachments have been included above under the \"Attachments\" section.\n\n    {{actions}}\n\n    {{messageDirections}}\n\n    {{recentMessages}}\n\n    # Instructions: Write the next message for {{agentName}}. Include an optional action if appropriate. {{actionNames}}\n    ` + messageCompletionFooter;\n","import { type Client, type IAgentRuntime } from '@elizaos/core';\nimport { ClientBase } from './base.js';\nimport { validateTwitterConfig, type TwitterConfig as LocalTwitterConfig } from './environment.js';\nimport { TwitterInteractionClient } from './interactions.js';\nimport { TwitterPostClient } from './post.js';\nimport { TwitterSearchClient } from './search.js';\nimport { TwitterSpaceClient } from './spaces.js';\nimport {\n  getCurrentAgentTwitterAccountStatus,\n  Logger,\n  SETTINGS,\n} from './settings/index.js';\nimport { TwitterClientStatus } from './monitor/state.js';\nimport {\n  twitterAccountStatus,\n  twitterPostCount,\n  twitterPostInterval,\n} from './monitor/metrics.js';\n\nexport type TwitterConfig = LocalTwitterConfig;\n\n/**\n * A manager that orchestrates all specialized Twitter logic:\n * - client: base operations (login, timeline caching, etc.)\n * - post: autonomous posting logic\n * - search: searching tweets / replying logic\n * - interaction: handling mentions, replies\n * - space: launching and managing Twitter Spaces (optional)\n */\nclass TwitterManager {\n  client: ClientBase;\n  post: TwitterPostClient;\n  search: TwitterSearchClient;\n  interaction: TwitterInteractionClient;\n  space?: TwitterSpaceClient;\n\n  constructor(\n    private runtime: IAgentRuntime,\n    twitterConfig: TwitterConfig,\n  ) {\n    // Pass twitterConfig to the base client\n    this.client = new ClientBase(runtime, twitterConfig);\n\n    // Posting logic\n    this.post = new TwitterPostClient(this.client, runtime);\n\n    // Optional search logic (enabled if TWITTER_SEARCH_ENABLE is true)\n    if (twitterConfig.TWITTER_SEARCH_ENABLE) {\n      this.client.logger.warn('Twitter/X client running in a mode that:');\n      this.client.logger.warn('1. violates consent of random users');\n      this.client.logger.warn('2. burns your rate limit');\n      this.client.logger.warn('3. can get your account banned');\n      this.client.logger.warn('use at your own risk');\n      this.search = new TwitterSearchClient(this.client, runtime);\n    }\n\n    // Mentions and interactions\n    this.interaction = new TwitterInteractionClient(this.client, runtime);\n\n    // Optional Spaces logic (enabled if TWITTER_SPACES_ENABLE is true)\n    if (twitterConfig.TWITTER_SPACES_ENABLE) {\n      this.space = new TwitterSpaceClient(this.client, runtime);\n    }\n\n    // console.log('TwitterManager constructor end');\n  }\n\n  // TODO get current state of the manager\n  // TODO get the queue length\n  // TODO get the manager's health\n  // TODO count the errors\n\n  async stop() {\n    return stop(this.runtime);\n  }\n}\n\nfunction hidePassword(url: string) {\n  if (!url) return url;\n\n  try {\n    const urlParts = new URL(url);\n    urlParts.password = '***';\n    return urlParts.toString();\n  } catch (error) {\n    return url;\n  }\n}\n\nexport const TwitterClientInterface: Client = {\n  // one loop to start all actions, so that can easy stop the client\n  async start(runtime: IAgentRuntime) {\n    const twitterConfig: TwitterConfig = await validateTwitterConfig(runtime);\n\n    // get proxy from config\n    const proxy = hidePassword(twitterConfig.TWITTER_HTTP_PROXY ?? '');\n    Logger.debug(\n      `Twitter client started username=${twitterConfig.TWITTER_USERNAME}`,\n    );\n\n    try {\n      twitterAccountStatus.labels(twitterConfig.TWITTER_USERNAME, proxy).set(1);\n      // init the post count\n      twitterPostCount.labels(twitterConfig.TWITTER_USERNAME).inc(0);\n      // if badder then max, there must be some issue\n      twitterPostInterval\n        .labels(twitterConfig.TWITTER_USERNAME)\n        .set(twitterConfig.POST_INTERVAL_MAX);\n\n      // only if the status is stopped can start a new client\n      if (\n        SETTINGS.account[twitterConfig.TWITTER_USERNAME] &&\n        SETTINGS.account[twitterConfig.TWITTER_USERNAME].status !==\n          TwitterClientStatus.STOPPED\n      ) {\n        const msg = `Twitter client ${twitterConfig.TWITTER_USERNAME} is not stopped, cannot start, status=${SETTINGS.account[twitterConfig.TWITTER_USERNAME]?.status}`;\n        throw new Error(msg);\n      }\n\n      // TODO if twitter username change\n      SETTINGS.agent[runtime.agentId] = twitterConfig;\n\n      const manager = new TwitterManager(runtime, twitterConfig);\n\n      // TODO fix transaction issue\n      // Initialize login/session\n      await manager.client.init();\n\n      // Start the posting loop\n      await manager.post.start();\n\n      // Start the search logic if it exists\n      if (manager.search) {\n        await manager.search.start();\n      }\n\n      // Start interactions (mentions, replies)\n      await manager.interaction.start();\n\n      // If Spaces are enabled, start the periodic check\n      if (manager.space) {\n        manager.space.startPeriodicSpaceCheck();\n      }\n\n      SETTINGS.account[twitterConfig.TWITTER_USERNAME].status =\n        TwitterClientStatus.RUNNING;\n      SETTINGS.account[twitterConfig.TWITTER_USERNAME].manager = manager;\n      return manager;\n    } catch (error) {\n      twitterAccountStatus.labels(twitterConfig.TWITTER_USERNAME).set(0);\n      throw error;\n    }\n  },\n\n  async stop(_runtime: IAgentRuntime) {\n    return stop(_runtime);\n  },\n};\n\nasync function stop(_runtime: IAgentRuntime) {\n  if (\n    getCurrentAgentTwitterAccountStatus(_runtime.agentId) ===\n    TwitterClientStatus.RUNNING\n  ) {\n    const twitterConfig = SETTINGS.agent[_runtime.agentId];\n    const username = twitterConfig.TWITTER_USERNAME;\n    const proxy = hidePassword(twitterConfig.TWITTER_HTTP_PROXY ?? '');\n\n    twitterAccountStatus.labels(username, proxy).set(2);\n\n    SETTINGS.account[username].status = TwitterClientStatus.STOPPING;\n    const manager: TwitterManager | null = SETTINGS.account[username].manager;\n    let maxCheckTimes = 60;\n\n    while (maxCheckTimes > 0) {\n      maxCheckTimes--;\n      // 2s\n      await new Promise((resolve) => setTimeout(resolve, 2000));\n\n      let ok = await manager.post.stop();\n      if (!ok) continue;\n\n      ok = await manager.interaction.stop();\n      if (!ok) continue;\n\n      if (manager.space) await manager.space.stopSpace();\n      if (manager.search) await manager.search.stop();\n\n      break;\n    }\n\n    if (maxCheckTimes === 0) {\n      throw new Error(\n        `Twitter client ${username} failed to stop, please try again`,\n      );\n    } else {\n      // should release the manager from global settings\n      SETTINGS.account[username].manager = null;\n      SETTINGS.account[username].status = TwitterClientStatus.STOPPED;\n      twitterAccountStatus.labels(username, proxy).set(0);\n      Logger.info(`Twitter client ${_runtime.agentId} stopped`);\n    }\n  } else {\n    Logger.warn(\n      `Twitter client ${_runtime.agentId} is not running, cannot stop`,\n    );\n  }\n}\n\nexport default TwitterClientInterface;\n"],"mappings":"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","names":["authToken","ct0","guestId","ActionTimelineType","SearchMode","stringToUuid","getEmbeddingZeroVector","getEmbeddingZeroVector","stringToUuid","elizaLogger","client","elizaLogger","stringToUuid","getEmbeddingZeroVector","client","SearchMode","stringToUuid","tweet","message","response","tweetId","getEmbeddingZeroVector","composeContext","getEmbeddingZeroVector","ModelClass","stringToUuid","ServiceType","stringToUuid","composeContext","ModelClass","client","getEmbeddingZeroVector","truncateContent","ServiceType","SearchMode","composeContext","generateMessageResponse","generateText","messageCompletionFooter","ModelClass","ServiceType","stringToUuid","messageCompletionFooter","client","SearchMode","generateText","ModelClass","stringToUuid","ServiceType","composeContext","generateMessageResponse","response","composeContext","generateText","ModelClass","ServiceType","elizaLogger","stringToUuid","composeContext","getEmbeddingZeroVector","generateMessageResponse","ModelClass","generateShouldRespond","messageCompletionFooter","shouldRespondFooter","twitterShouldRespondTemplate","elizaLogger","stringToUuid","getEmbeddingZeroVector","composeContext","generateMessageResponse","ModelClass","twitterShouldRespondTemplate","generateShouldRespond","composeContext","generateText","ModelClass","client","ServiceType"]}